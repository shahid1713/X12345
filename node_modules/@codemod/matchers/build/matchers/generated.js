"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.classImplements = exports.ClassImplementsMatcher = exports.classExpression = exports.ClassExpressionMatcher = exports.classDeclaration = exports.ClassDeclarationMatcher = exports.classBody = exports.ClassBodyMatcher = exports.classAccessorProperty = exports.ClassAccessorPropertyMatcher = exports.catchClause = exports.CatchClauseMatcher = exports.callExpression = exports.CallExpressionMatcher = exports.breakStatement = exports.BreakStatementMatcher = exports.booleanTypeAnnotation = exports.BooleanTypeAnnotationMatcher = exports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotationMatcher = exports.booleanLiteral = exports.BooleanLiteralMatcher = exports.blockStatement = exports.BlockStatementMatcher = exports.bindExpression = exports.BindExpressionMatcher = exports.binaryExpression = exports.BinaryExpressionMatcher = exports.bigIntLiteral = exports.BigIntLiteralMatcher = exports.awaitExpression = exports.AwaitExpressionMatcher = exports.assignmentPattern = exports.AssignmentPatternMatcher = exports.assignmentExpression = exports.AssignmentExpressionMatcher = exports.arrowFunctionExpression = exports.ArrowFunctionExpressionMatcher = exports.arrayTypeAnnotation = exports.ArrayTypeAnnotationMatcher = exports.arrayPattern = exports.ArrayPatternMatcher = exports.arrayExpression = exports.ArrayExpressionMatcher = exports.argumentPlaceholder = exports.ArgumentPlaceholderMatcher = exports.anyTypeAnnotation = exports.AnyTypeAnnotationMatcher = exports.super = exports.import = void 0;
exports.emptyStatement = exports.EmptyStatementMatcher = exports.doWhileStatement = exports.DoWhileStatementMatcher = exports.doExpression = exports.DoExpressionMatcher = exports.directiveLiteral = exports.DirectiveLiteralMatcher = exports.directive = exports.DirectiveMatcher = exports.decorator = exports.DecoratorMatcher = exports.declaredPredicate = exports.DeclaredPredicateMatcher = exports.declareVariable = exports.DeclareVariableMatcher = exports.declareTypeAlias = exports.DeclareTypeAliasMatcher = exports.declareOpaqueType = exports.DeclareOpaqueTypeMatcher = exports.declareModuleExports = exports.DeclareModuleExportsMatcher = exports.declareModule = exports.DeclareModuleMatcher = exports.declareInterface = exports.DeclareInterfaceMatcher = exports.declareFunction = exports.DeclareFunctionMatcher = exports.declareExportDeclaration = exports.DeclareExportDeclarationMatcher = exports.declareExportAllDeclaration = exports.DeclareExportAllDeclarationMatcher = exports.declareClass = exports.DeclareClassMatcher = exports.decimalLiteral = exports.DecimalLiteralMatcher = exports.debuggerStatement = exports.DebuggerStatementMatcher = exports.continueStatement = exports.ContinueStatementMatcher = exports.conditionalExpression = exports.ConditionalExpressionMatcher = exports.classProperty = exports.ClassPropertyMatcher = exports.classPrivateProperty = exports.ClassPrivatePropertyMatcher = exports.classPrivateMethod = exports.ClassPrivateMethodMatcher = exports.classMethod = exports.ClassMethodMatcher = void 0;
exports.functionTypeAnnotation = exports.FunctionTypeAnnotationMatcher = exports.functionExpression = exports.FunctionExpressionMatcher = exports.functionDeclaration = exports.FunctionDeclarationMatcher = exports.forStatement = exports.ForStatementMatcher = exports.forOfStatement = exports.ForOfStatementMatcher = exports.forInStatement = exports.ForInStatementMatcher = exports.file = exports.FileMatcher = exports.expressionStatement = exports.ExpressionStatementMatcher = exports.exportSpecifier = exports.ExportSpecifierMatcher = exports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifierMatcher = exports.exportNamedDeclaration = exports.ExportNamedDeclarationMatcher = exports.exportDefaultSpecifier = exports.ExportDefaultSpecifierMatcher = exports.exportDefaultDeclaration = exports.ExportDefaultDeclarationMatcher = exports.exportAllDeclaration = exports.ExportAllDeclarationMatcher = exports.existsTypeAnnotation = exports.ExistsTypeAnnotationMatcher = exports.enumSymbolBody = exports.EnumSymbolBodyMatcher = exports.enumStringMember = exports.EnumStringMemberMatcher = exports.enumStringBody = exports.EnumStringBodyMatcher = exports.enumNumberMember = exports.EnumNumberMemberMatcher = exports.enumNumberBody = exports.EnumNumberBodyMatcher = exports.enumDefaultedMember = exports.EnumDefaultedMemberMatcher = exports.enumDeclaration = exports.EnumDeclarationMatcher = exports.enumBooleanMember = exports.EnumBooleanMemberMatcher = exports.enumBooleanBody = exports.EnumBooleanBodyMatcher = exports.emptyTypeAnnotation = exports.EmptyTypeAnnotationMatcher = void 0;
exports.jsxIdentifier = exports.JSXIdentifierMatcher = exports.jsxFragment = exports.JSXFragmentMatcher = exports.jsxExpressionContainer = exports.JSXExpressionContainerMatcher = exports.jsxEmptyExpression = exports.JSXEmptyExpressionMatcher = exports.jsxElement = exports.JSXElementMatcher = exports.jsxClosingFragment = exports.JSXClosingFragmentMatcher = exports.jsxClosingElement = exports.JSXClosingElementMatcher = exports.jsxAttribute = exports.JSXAttributeMatcher = exports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotationMatcher = exports.interpreterDirective = exports.InterpreterDirectiveMatcher = exports.interfaceTypeAnnotation = exports.InterfaceTypeAnnotationMatcher = exports.interfaceExtends = exports.InterfaceExtendsMatcher = exports.interfaceDeclaration = exports.InterfaceDeclarationMatcher = exports.inferredPredicate = exports.InferredPredicateMatcher = exports.indexedAccessType = exports.IndexedAccessTypeMatcher = exports.importSpecifier = exports.ImportSpecifierMatcher = exports.importNamespaceSpecifier = exports.ImportNamespaceSpecifierMatcher = exports.importDefaultSpecifier = exports.ImportDefaultSpecifierMatcher = exports.importDeclaration = exports.ImportDeclarationMatcher = exports.importAttribute = exports.ImportAttributeMatcher = exports.Import = exports.ImportMatcher = exports.ifStatement = exports.IfStatementMatcher = exports.identifier = exports.IdentifierMatcher = exports.genericTypeAnnotation = exports.GenericTypeAnnotationMatcher = exports.functionTypeParam = exports.FunctionTypeParamMatcher = void 0;
exports.objectProperty = exports.ObjectPropertyMatcher = exports.objectPattern = exports.ObjectPatternMatcher = exports.objectMethod = exports.ObjectMethodMatcher = exports.objectExpression = exports.ObjectExpressionMatcher = exports.numericLiteral = exports.NumericLiteralMatcher = exports.numberTypeAnnotation = exports.NumberTypeAnnotationMatcher = exports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotationMatcher = exports.nullableTypeAnnotation = exports.NullableTypeAnnotationMatcher = exports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotationMatcher = exports.nullLiteral = exports.NullLiteralMatcher = exports.noop = exports.NoopMatcher = exports.newExpression = exports.NewExpressionMatcher = exports.moduleExpression = exports.ModuleExpressionMatcher = exports.mixedTypeAnnotation = exports.MixedTypeAnnotationMatcher = exports.metaProperty = exports.MetaPropertyMatcher = exports.memberExpression = exports.MemberExpressionMatcher = exports.logicalExpression = exports.LogicalExpressionMatcher = exports.labeledStatement = exports.LabeledStatementMatcher = exports.jsxText = exports.JSXTextMatcher = exports.jsxSpreadChild = exports.JSXSpreadChildMatcher = exports.jsxSpreadAttribute = exports.JSXSpreadAttributeMatcher = exports.jsxOpeningFragment = exports.JSXOpeningFragmentMatcher = exports.jsxOpeningElement = exports.JSXOpeningElementMatcher = exports.jsxNamespacedName = exports.JSXNamespacedNameMatcher = exports.jsxMemberExpression = exports.JSXMemberExpressionMatcher = void 0;
exports.staticBlock = exports.StaticBlockMatcher = exports.spreadElement = exports.SpreadElementMatcher = exports.sequenceExpression = exports.SequenceExpressionMatcher = exports.returnStatement = exports.ReturnStatementMatcher = exports.restElement = exports.RestElementMatcher = exports.regExpLiteral = exports.RegExpLiteralMatcher = exports.recordExpression = exports.RecordExpressionMatcher = exports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifierMatcher = exports.program = exports.ProgramMatcher = exports.privateName = exports.PrivateNameMatcher = exports.placeholder = exports.PlaceholderMatcher = exports.pipelineTopicExpression = exports.PipelineTopicExpressionMatcher = exports.pipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReferenceMatcher = exports.pipelineBareFunction = exports.PipelineBareFunctionMatcher = exports.parenthesizedExpression = exports.ParenthesizedExpressionMatcher = exports.optionalMemberExpression = exports.OptionalMemberExpressionMatcher = exports.optionalIndexedAccessType = exports.OptionalIndexedAccessTypeMatcher = exports.optionalCallExpression = exports.OptionalCallExpressionMatcher = exports.opaqueType = exports.OpaqueTypeMatcher = exports.objectTypeSpreadProperty = exports.ObjectTypeSpreadPropertyMatcher = exports.objectTypeProperty = exports.ObjectTypePropertyMatcher = exports.objectTypeInternalSlot = exports.ObjectTypeInternalSlotMatcher = exports.objectTypeIndexer = exports.ObjectTypeIndexerMatcher = exports.objectTypeCallProperty = exports.ObjectTypeCallPropertyMatcher = exports.objectTypeAnnotation = exports.ObjectTypeAnnotationMatcher = void 0;
exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclarationMatcher = exports.tsFunctionType = exports.TSFunctionTypeMatcher = exports.tsExternalModuleReference = exports.TSExternalModuleReferenceMatcher = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArgumentsMatcher = exports.tsExportAssignment = exports.TSExportAssignmentMatcher = exports.tsEnumMember = exports.TSEnumMemberMatcher = exports.tsEnumDeclaration = exports.TSEnumDeclarationMatcher = exports.tsDeclareMethod = exports.TSDeclareMethodMatcher = exports.tsDeclareFunction = exports.TSDeclareFunctionMatcher = exports.tsConstructorType = exports.TSConstructorTypeMatcher = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclarationMatcher = exports.tsConditionalType = exports.TSConditionalTypeMatcher = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclarationMatcher = exports.tsBooleanKeyword = exports.TSBooleanKeywordMatcher = exports.tsBigIntKeyword = exports.TSBigIntKeywordMatcher = exports.tsAsExpression = exports.TSAsExpressionMatcher = exports.tsArrayType = exports.TSArrayTypeMatcher = exports.tsAnyKeyword = exports.TSAnyKeywordMatcher = exports.symbolTypeAnnotation = exports.SymbolTypeAnnotationMatcher = exports.switchStatement = exports.SwitchStatementMatcher = exports.switchCase = exports.SwitchCaseMatcher = exports.Super = exports.SuperMatcher = exports.stringTypeAnnotation = exports.StringTypeAnnotationMatcher = exports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotationMatcher = exports.stringLiteral = exports.StringLiteralMatcher = void 0;
exports.tsPropertySignature = exports.TSPropertySignatureMatcher = exports.tsParenthesizedType = exports.TSParenthesizedTypeMatcher = exports.tsParameterProperty = exports.TSParameterPropertyMatcher = exports.tsOptionalType = exports.TSOptionalTypeMatcher = exports.tsObjectKeyword = exports.TSObjectKeywordMatcher = exports.tsNumberKeyword = exports.TSNumberKeywordMatcher = exports.tsNullKeyword = exports.TSNullKeywordMatcher = exports.tsNonNullExpression = exports.TSNonNullExpressionMatcher = exports.tsNeverKeyword = exports.TSNeverKeywordMatcher = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclarationMatcher = exports.tsNamedTupleMember = exports.TSNamedTupleMemberMatcher = exports.tsModuleDeclaration = exports.TSModuleDeclarationMatcher = exports.tsModuleBlock = exports.TSModuleBlockMatcher = exports.tsMethodSignature = exports.TSMethodSignatureMatcher = exports.tsMappedType = exports.TSMappedTypeMatcher = exports.tsLiteralType = exports.TSLiteralTypeMatcher = exports.tsIntrinsicKeyword = exports.TSIntrinsicKeywordMatcher = exports.tsIntersectionType = exports.TSIntersectionTypeMatcher = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclarationMatcher = exports.tsInterfaceBody = exports.TSInterfaceBodyMatcher = exports.tsInstantiationExpression = exports.TSInstantiationExpressionMatcher = exports.tsInferType = exports.TSInferTypeMatcher = exports.tsIndexedAccessType = exports.TSIndexedAccessTypeMatcher = exports.tsIndexSignature = exports.TSIndexSignatureMatcher = exports.tsImportType = exports.TSImportTypeMatcher = void 0;
exports.templateLiteral = exports.TemplateLiteralMatcher = exports.templateElement = exports.TemplateElementMatcher = exports.taggedTemplateExpression = exports.TaggedTemplateExpressionMatcher = exports.tsVoidKeyword = exports.TSVoidKeywordMatcher = exports.tsUnknownKeyword = exports.TSUnknownKeywordMatcher = exports.tsUnionType = exports.TSUnionTypeMatcher = exports.tsUndefinedKeyword = exports.TSUndefinedKeywordMatcher = exports.tsTypeReference = exports.TSTypeReferenceMatcher = exports.tsTypeQuery = exports.TSTypeQueryMatcher = exports.tsTypePredicate = exports.TSTypePredicateMatcher = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiationMatcher = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclarationMatcher = exports.tsTypeParameter = exports.TSTypeParameterMatcher = exports.tsTypeOperator = exports.TSTypeOperatorMatcher = exports.tsTypeLiteral = exports.TSTypeLiteralMatcher = exports.tsTypeAssertion = exports.TSTypeAssertionMatcher = exports.tsTypeAnnotation = exports.TSTypeAnnotationMatcher = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclarationMatcher = exports.tsTupleType = exports.TSTupleTypeMatcher = exports.tsThisType = exports.TSThisTypeMatcher = exports.tsSymbolKeyword = exports.TSSymbolKeywordMatcher = exports.tsStringKeyword = exports.TSStringKeywordMatcher = exports.tsSatisfiesExpression = exports.TSSatisfiesExpressionMatcher = exports.tsRestType = exports.TSRestTypeMatcher = exports.tsQualifiedName = exports.TSQualifiedNameMatcher = void 0;
exports.yieldExpression = exports.YieldExpressionMatcher = exports.withStatement = exports.WithStatementMatcher = exports.whileStatement = exports.WhileStatementMatcher = exports.voidTypeAnnotation = exports.VoidTypeAnnotationMatcher = exports.variance = exports.VarianceMatcher = exports.variableDeclarator = exports.VariableDeclaratorMatcher = exports.variableDeclaration = exports.VariableDeclarationMatcher = exports.v8IntrinsicIdentifier = exports.V8IntrinsicIdentifierMatcher = exports.updateExpression = exports.UpdateExpressionMatcher = exports.unionTypeAnnotation = exports.UnionTypeAnnotationMatcher = exports.unaryExpression = exports.UnaryExpressionMatcher = exports.typeofTypeAnnotation = exports.TypeofTypeAnnotationMatcher = exports.typeParameterInstantiation = exports.TypeParameterInstantiationMatcher = exports.typeParameterDeclaration = exports.TypeParameterDeclarationMatcher = exports.typeParameter = exports.TypeParameterMatcher = exports.typeCastExpression = exports.TypeCastExpressionMatcher = exports.typeAnnotation = exports.TypeAnnotationMatcher = exports.typeAlias = exports.TypeAliasMatcher = exports.tupleTypeAnnotation = exports.TupleTypeAnnotationMatcher = exports.tupleExpression = exports.TupleExpressionMatcher = exports.tryStatement = exports.TryStatementMatcher = exports.topicReference = exports.TopicReferenceMatcher = exports.throwStatement = exports.ThrowStatementMatcher = exports.thisTypeAnnotation = exports.ThisTypeAnnotationMatcher = exports.thisExpression = exports.ThisExpressionMatcher = void 0;
/* DO NOT EDIT. This file was generated by 'script/rebuild' */
/* eslint-disable */
const t = __importStar(require("@babel/types"));
const tupleOf_1 = require("./tupleOf");
const Matcher_1 = require("./Matcher");
class AnyTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isAnyTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.AnyTypeAnnotationMatcher = AnyTypeAnnotationMatcher;
function anyTypeAnnotation() {
    return new AnyTypeAnnotationMatcher();
}
exports.anyTypeAnnotation = anyTypeAnnotation;
class ArgumentPlaceholderMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isArgumentPlaceholder(node)) {
            return false;
        }
        return true;
    }
}
exports.ArgumentPlaceholderMatcher = ArgumentPlaceholderMatcher;
function argumentPlaceholder() {
    return new ArgumentPlaceholderMatcher();
}
exports.argumentPlaceholder = argumentPlaceholder;
class ArrayExpressionMatcher extends Matcher_1.Matcher {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isArrayExpression(node)) {
            return false;
        }
        if (typeof this.elements === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.elements)) {
            if (!(0, tupleOf_1.tupleOf)(...this.elements).matchValue(node.elements, [
                ...keys,
                'elements',
            ])) {
                return false;
            }
        }
        else if (!this.elements.matchValue(node.elements, [...keys, 'elements'])) {
            return false;
        }
        return true;
    }
}
exports.ArrayExpressionMatcher = ArrayExpressionMatcher;
function arrayExpression(elements) {
    return new ArrayExpressionMatcher(elements);
}
exports.arrayExpression = arrayExpression;
class ArrayPatternMatcher extends Matcher_1.Matcher {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isArrayPattern(node)) {
            return false;
        }
        if (typeof this.elements === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.elements)) {
            if (!(0, tupleOf_1.tupleOf)(...this.elements).matchValue(node.elements, [
                ...keys,
                'elements',
            ])) {
                return false;
            }
        }
        else if (!this.elements.matchValue(node.elements, [...keys, 'elements'])) {
            return false;
        }
        return true;
    }
}
exports.ArrayPatternMatcher = ArrayPatternMatcher;
function arrayPattern(elements) {
    return new ArrayPatternMatcher(elements);
}
exports.arrayPattern = arrayPattern;
class ArrayTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(elementType) {
        super();
        this.elementType = elementType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isArrayTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.elementType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.elementType.matchValue(node.elementType, [...keys, 'elementType'])) {
            return false;
        }
        return true;
    }
}
exports.ArrayTypeAnnotationMatcher = ArrayTypeAnnotationMatcher;
function arrayTypeAnnotation(elementType) {
    return new ArrayTypeAnnotationMatcher(elementType);
}
exports.arrayTypeAnnotation = arrayTypeAnnotation;
class ArrowFunctionExpressionMatcher extends Matcher_1.Matcher {
    constructor(params, body, async) {
        super();
        this.params = params;
        this.body = body;
        this.async = async;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isArrowFunctionExpression(node)) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.async === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.async === 'boolean') {
            if (this.async !== node.async) {
                return false;
            }
        }
        else if (!this.async.matchValue(node.async, [...keys, 'async'])) {
            return false;
        }
        return true;
    }
}
exports.ArrowFunctionExpressionMatcher = ArrowFunctionExpressionMatcher;
function arrowFunctionExpression(params, body, async) {
    return new ArrowFunctionExpressionMatcher(params, body, async);
}
exports.arrowFunctionExpression = arrowFunctionExpression;
class AssignmentExpressionMatcher extends Matcher_1.Matcher {
    constructor(operator, left, right) {
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isAssignmentExpression(node)) {
            return false;
        }
        if (typeof this.operator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.operator === 'string') {
            if (this.operator !== node.operator) {
                return false;
            }
        }
        else if (!this.operator.matchValue(node.operator, [...keys, 'operator'])) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.AssignmentExpressionMatcher = AssignmentExpressionMatcher;
function assignmentExpression(operator, left, right) {
    return new AssignmentExpressionMatcher(operator, left, right);
}
exports.assignmentExpression = assignmentExpression;
class AssignmentPatternMatcher extends Matcher_1.Matcher {
    constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isAssignmentPattern(node)) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.AssignmentPatternMatcher = AssignmentPatternMatcher;
function assignmentPattern(left, right) {
    return new AssignmentPatternMatcher(left, right);
}
exports.assignmentPattern = assignmentPattern;
class AwaitExpressionMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isAwaitExpression(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.AwaitExpressionMatcher = AwaitExpressionMatcher;
function awaitExpression(argument) {
    return new AwaitExpressionMatcher(argument);
}
exports.awaitExpression = awaitExpression;
class BigIntLiteralMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBigIntLiteral(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.BigIntLiteralMatcher = BigIntLiteralMatcher;
function bigIntLiteral(value) {
    return new BigIntLiteralMatcher(value);
}
exports.bigIntLiteral = bigIntLiteral;
class BinaryExpressionMatcher extends Matcher_1.Matcher {
    constructor(operator, left, right) {
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBinaryExpression(node)) {
            return false;
        }
        if (typeof this.operator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.operator === 'string') {
            if (this.operator !== node.operator) {
                return false;
            }
        }
        else if (!this.operator.matchValue(node.operator, [...keys, 'operator'])) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.BinaryExpressionMatcher = BinaryExpressionMatcher;
function binaryExpression(operator, left, right) {
    return new BinaryExpressionMatcher(operator, left, right);
}
exports.binaryExpression = binaryExpression;
class BindExpressionMatcher extends Matcher_1.Matcher {
    constructor(object, callee) {
        super();
        this.object = object;
        this.callee = callee;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBindExpression(node)) {
            return false;
        }
        if (typeof this.object === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.object.matchValue(node.object, [...keys, 'object'])) {
            return false;
        }
        if (typeof this.callee === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.callee.matchValue(node.callee, [...keys, 'callee'])) {
            return false;
        }
        return true;
    }
}
exports.BindExpressionMatcher = BindExpressionMatcher;
function bindExpression(object, callee) {
    return new BindExpressionMatcher(object, callee);
}
exports.bindExpression = bindExpression;
class BlockStatementMatcher extends Matcher_1.Matcher {
    constructor(body, directives) {
        super();
        this.body = body;
        this.directives = directives;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBlockStatement(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.body)) {
            if (!(0, tupleOf_1.tupleOf)(...this.body).matchValue(node.body, [...keys, 'body'])) {
                return false;
            }
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.directives === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.directives)) {
            if (!(0, tupleOf_1.tupleOf)(...this.directives).matchValue(node.directives, [
                ...keys,
                'directives',
            ])) {
                return false;
            }
        }
        else if (!this.directives.matchValue(node.directives, [...keys, 'directives'])) {
            return false;
        }
        return true;
    }
}
exports.BlockStatementMatcher = BlockStatementMatcher;
function blockStatement(body, directives) {
    return new BlockStatementMatcher(body, directives);
}
exports.blockStatement = blockStatement;
class BooleanLiteralMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBooleanLiteral(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'boolean') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.BooleanLiteralMatcher = BooleanLiteralMatcher;
function booleanLiteral(value) {
    return new BooleanLiteralMatcher(value);
}
exports.booleanLiteral = booleanLiteral;
class BooleanLiteralTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBooleanLiteralTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'boolean') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.BooleanLiteralTypeAnnotationMatcher = BooleanLiteralTypeAnnotationMatcher;
function booleanLiteralTypeAnnotation(value) {
    return new BooleanLiteralTypeAnnotationMatcher(value);
}
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
class BooleanTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBooleanTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.BooleanTypeAnnotationMatcher = BooleanTypeAnnotationMatcher;
function booleanTypeAnnotation() {
    return new BooleanTypeAnnotationMatcher();
}
exports.booleanTypeAnnotation = booleanTypeAnnotation;
class BreakStatementMatcher extends Matcher_1.Matcher {
    constructor(label) {
        super();
        this.label = label;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isBreakStatement(node)) {
            return false;
        }
        if (typeof this.label === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.label === null) {
            // null matcher means we expect null value
            if (node.label !== null) {
                return false;
            }
        }
        else if (!this.label.matchValue(node.label, [...keys, 'label'])) {
            return false;
        }
        return true;
    }
}
exports.BreakStatementMatcher = BreakStatementMatcher;
function breakStatement(label) {
    return new BreakStatementMatcher(label);
}
exports.breakStatement = breakStatement;
class CallExpressionMatcher extends Matcher_1.Matcher {
    constructor(callee, _arguments) {
        super();
        this.callee = callee;
        this._arguments = _arguments;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isCallExpression(node)) {
            return false;
        }
        if (typeof this.callee === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.callee.matchValue(node.callee, [...keys, 'callee'])) {
            return false;
        }
        if (typeof this._arguments === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this._arguments)) {
            if (!(0, tupleOf_1.tupleOf)(...this._arguments).matchValue(node.arguments, [
                ...keys,
                'arguments',
            ])) {
                return false;
            }
        }
        else if (!this._arguments.matchValue(node.arguments, [...keys, 'arguments'])) {
            return false;
        }
        return true;
    }
}
exports.CallExpressionMatcher = CallExpressionMatcher;
function callExpression(callee, _arguments) {
    return new CallExpressionMatcher(callee, _arguments);
}
exports.callExpression = callExpression;
class CatchClauseMatcher extends Matcher_1.Matcher {
    constructor(param, body) {
        super();
        this.param = param;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isCatchClause(node)) {
            return false;
        }
        if (typeof this.param === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.param === null) {
            // null matcher means we expect null value
            if (node.param !== null) {
                return false;
            }
        }
        else if (!this.param.matchValue(node.param, [...keys, 'param'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.CatchClauseMatcher = CatchClauseMatcher;
function catchClause(param, body) {
    return new CatchClauseMatcher(param, body);
}
exports.catchClause = catchClause;
class ClassAccessorPropertyMatcher extends Matcher_1.Matcher {
    constructor(key, value, typeAnnotation, decorators, computed, _static) {
        super();
        this.key = key;
        this.value = value;
        this.typeAnnotation = typeAnnotation;
        this.decorators = decorators;
        this.computed = computed;
        this._static = _static;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassAccessorProperty(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.value === null) {
            // null matcher means we expect null value
            if (node.value !== null) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this._static === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._static === 'boolean') {
            if (this._static !== node.static) {
                return false;
            }
        }
        else if (!this._static.matchValue(node.static, [...keys, 'static'])) {
            return false;
        }
        return true;
    }
}
exports.ClassAccessorPropertyMatcher = ClassAccessorPropertyMatcher;
function classAccessorProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return new ClassAccessorPropertyMatcher(key, value, typeAnnotation, decorators, computed, _static);
}
exports.classAccessorProperty = classAccessorProperty;
class ClassBodyMatcher extends Matcher_1.Matcher {
    constructor(body) {
        super();
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassBody(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.body)) {
            if (!(0, tupleOf_1.tupleOf)(...this.body).matchValue(node.body, [...keys, 'body'])) {
                return false;
            }
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.ClassBodyMatcher = ClassBodyMatcher;
function classBody(body) {
    return new ClassBodyMatcher(body);
}
exports.classBody = classBody;
class ClassDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, superClass, body, decorators) {
        super();
        this.id = id;
        this.superClass = superClass;
        this.body = body;
        this.decorators = decorators;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.superClass === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.superClass === null) {
            // null matcher means we expect null value
            if (node.superClass !== null) {
                return false;
            }
        }
        else if (!this.superClass.matchValue(node.superClass, [...keys, 'superClass'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        return true;
    }
}
exports.ClassDeclarationMatcher = ClassDeclarationMatcher;
function classDeclaration(id, superClass, body, decorators) {
    return new ClassDeclarationMatcher(id, superClass, body, decorators);
}
exports.classDeclaration = classDeclaration;
class ClassExpressionMatcher extends Matcher_1.Matcher {
    constructor(id, superClass, body, decorators) {
        super();
        this.id = id;
        this.superClass = superClass;
        this.body = body;
        this.decorators = decorators;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassExpression(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.id === null) {
            // null matcher means we expect null value
            if (node.id !== null) {
                return false;
            }
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.superClass === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.superClass === null) {
            // null matcher means we expect null value
            if (node.superClass !== null) {
                return false;
            }
        }
        else if (!this.superClass.matchValue(node.superClass, [...keys, 'superClass'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        return true;
    }
}
exports.ClassExpressionMatcher = ClassExpressionMatcher;
function classExpression(id, superClass, body, decorators) {
    return new ClassExpressionMatcher(id, superClass, body, decorators);
}
exports.classExpression = classExpression;
class ClassImplementsMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassImplements(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.ClassImplementsMatcher = ClassImplementsMatcher;
function classImplements(id, typeParameters) {
    return new ClassImplementsMatcher(id, typeParameters);
}
exports.classImplements = classImplements;
class ClassMethodMatcher extends Matcher_1.Matcher {
    constructor(kind, key, params, body, computed, _static, generator, async) {
        super();
        this.kind = kind;
        this.key = key;
        this.params = params;
        this.body = body;
        this.computed = computed;
        this._static = _static;
        this.generator = generator;
        this.async = async;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassMethod(node)) {
            return false;
        }
        if (typeof this.kind === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.kind === 'string') {
            if (this.kind !== node.kind) {
                return false;
            }
        }
        else if (!this.kind.matchValue(node.kind, [...keys, 'kind'])) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this._static === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._static === 'boolean') {
            if (this._static !== node.static) {
                return false;
            }
        }
        else if (!this._static.matchValue(node.static, [...keys, 'static'])) {
            return false;
        }
        if (typeof this.generator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.generator === 'boolean') {
            if (this.generator !== node.generator) {
                return false;
            }
        }
        else if (!this.generator.matchValue(node.generator, [...keys, 'generator'])) {
            return false;
        }
        if (typeof this.async === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.async === 'boolean') {
            if (this.async !== node.async) {
                return false;
            }
        }
        else if (!this.async.matchValue(node.async, [...keys, 'async'])) {
            return false;
        }
        return true;
    }
}
exports.ClassMethodMatcher = ClassMethodMatcher;
function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return new ClassMethodMatcher(kind, key, params, body, computed, _static, generator, async);
}
exports.classMethod = classMethod;
class ClassPrivateMethodMatcher extends Matcher_1.Matcher {
    constructor(kind, key, params, body, _static) {
        super();
        this.kind = kind;
        this.key = key;
        this.params = params;
        this.body = body;
        this._static = _static;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassPrivateMethod(node)) {
            return false;
        }
        if (typeof this.kind === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.kind === 'string') {
            if (this.kind !== node.kind) {
                return false;
            }
        }
        else if (!this.kind.matchValue(node.kind, [...keys, 'kind'])) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this._static === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._static === 'boolean') {
            if (this._static !== node.static) {
                return false;
            }
        }
        else if (!this._static.matchValue(node.static, [...keys, 'static'])) {
            return false;
        }
        return true;
    }
}
exports.ClassPrivateMethodMatcher = ClassPrivateMethodMatcher;
function classPrivateMethod(kind, key, params, body, _static) {
    return new ClassPrivateMethodMatcher(kind, key, params, body, _static);
}
exports.classPrivateMethod = classPrivateMethod;
class ClassPrivatePropertyMatcher extends Matcher_1.Matcher {
    constructor(key, value, decorators, _static) {
        super();
        this.key = key;
        this.value = value;
        this.decorators = decorators;
        this._static = _static;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassPrivateProperty(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.value === null) {
            // null matcher means we expect null value
            if (node.value !== null) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        if (typeof this._static === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._static === 'boolean') {
            if (this._static !== node.static) {
                return false;
            }
        }
        else if (!this._static.matchValue(node.static, [...keys, 'static'])) {
            return false;
        }
        return true;
    }
}
exports.ClassPrivatePropertyMatcher = ClassPrivatePropertyMatcher;
function classPrivateProperty(key, value, decorators, _static) {
    return new ClassPrivatePropertyMatcher(key, value, decorators, _static);
}
exports.classPrivateProperty = classPrivateProperty;
class ClassPropertyMatcher extends Matcher_1.Matcher {
    constructor(key, value, typeAnnotation, decorators, computed, _static) {
        super();
        this.key = key;
        this.value = value;
        this.typeAnnotation = typeAnnotation;
        this.decorators = decorators;
        this.computed = computed;
        this._static = _static;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isClassProperty(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.value === null) {
            // null matcher means we expect null value
            if (node.value !== null) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this._static === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._static === 'boolean') {
            if (this._static !== node.static) {
                return false;
            }
        }
        else if (!this._static.matchValue(node.static, [...keys, 'static'])) {
            return false;
        }
        return true;
    }
}
exports.ClassPropertyMatcher = ClassPropertyMatcher;
function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return new ClassPropertyMatcher(key, value, typeAnnotation, decorators, computed, _static);
}
exports.classProperty = classProperty;
class ConditionalExpressionMatcher extends Matcher_1.Matcher {
    constructor(test, consequent, alternate) {
        super();
        this.test = test;
        this.consequent = consequent;
        this.alternate = alternate;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isConditionalExpression(node)) {
            return false;
        }
        if (typeof this.test === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.test.matchValue(node.test, [...keys, 'test'])) {
            return false;
        }
        if (typeof this.consequent === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.consequent.matchValue(node.consequent, [...keys, 'consequent'])) {
            return false;
        }
        if (typeof this.alternate === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.alternate.matchValue(node.alternate, [...keys, 'alternate'])) {
            return false;
        }
        return true;
    }
}
exports.ConditionalExpressionMatcher = ConditionalExpressionMatcher;
function conditionalExpression(test, consequent, alternate) {
    return new ConditionalExpressionMatcher(test, consequent, alternate);
}
exports.conditionalExpression = conditionalExpression;
class ContinueStatementMatcher extends Matcher_1.Matcher {
    constructor(label) {
        super();
        this.label = label;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isContinueStatement(node)) {
            return false;
        }
        if (typeof this.label === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.label === null) {
            // null matcher means we expect null value
            if (node.label !== null) {
                return false;
            }
        }
        else if (!this.label.matchValue(node.label, [...keys, 'label'])) {
            return false;
        }
        return true;
    }
}
exports.ContinueStatementMatcher = ContinueStatementMatcher;
function continueStatement(label) {
    return new ContinueStatementMatcher(label);
}
exports.continueStatement = continueStatement;
class DebuggerStatementMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDebuggerStatement(node)) {
            return false;
        }
        return true;
    }
}
exports.DebuggerStatementMatcher = DebuggerStatementMatcher;
function debuggerStatement() {
    return new DebuggerStatementMatcher();
}
exports.debuggerStatement = debuggerStatement;
class DecimalLiteralMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDecimalLiteral(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.DecimalLiteralMatcher = DecimalLiteralMatcher;
function decimalLiteral(value) {
    return new DecimalLiteralMatcher(value);
}
exports.decimalLiteral = decimalLiteral;
class DeclareClassMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, _extends, body) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this._extends = _extends;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareClass(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this._extends === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._extends === null) {
            // null matcher means we expect null value
            if (node.extends !== null) {
                return false;
            }
        }
        else if (Array.isArray(this._extends)) {
            if (!(0, tupleOf_1.tupleOf)(...this._extends).matchValue(node.extends, [
                ...keys,
                'extends',
            ])) {
                return false;
            }
        }
        else if (!this._extends.matchValue(node.extends, [...keys, 'extends'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareClassMatcher = DeclareClassMatcher;
function declareClass(id, typeParameters, _extends, body) {
    return new DeclareClassMatcher(id, typeParameters, _extends, body);
}
exports.declareClass = declareClass;
class DeclareExportAllDeclarationMatcher extends Matcher_1.Matcher {
    constructor(source) {
        super();
        this.source = source;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareExportAllDeclaration(node)) {
            return false;
        }
        if (typeof this.source === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.source.matchValue(node.source, [...keys, 'source'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareExportAllDeclarationMatcher = DeclareExportAllDeclarationMatcher;
function declareExportAllDeclaration(source) {
    return new DeclareExportAllDeclarationMatcher(source);
}
exports.declareExportAllDeclaration = declareExportAllDeclaration;
class DeclareExportDeclarationMatcher extends Matcher_1.Matcher {
    constructor(declaration, specifiers, source) {
        super();
        this.declaration = declaration;
        this.specifiers = specifiers;
        this.source = source;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareExportDeclaration(node)) {
            return false;
        }
        if (typeof this.declaration === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.declaration === null) {
            // null matcher means we expect null value
            if (node.declaration !== null) {
                return false;
            }
        }
        else if (!this.declaration.matchValue(node.declaration, [...keys, 'declaration'])) {
            return false;
        }
        if (typeof this.specifiers === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.specifiers === null) {
            // null matcher means we expect null value
            if (node.specifiers !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.specifiers)) {
            if (!(0, tupleOf_1.tupleOf)(...this.specifiers).matchValue(node.specifiers, [
                ...keys,
                'specifiers',
            ])) {
                return false;
            }
        }
        else if (!this.specifiers.matchValue(node.specifiers, [...keys, 'specifiers'])) {
            return false;
        }
        if (typeof this.source === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.source === null) {
            // null matcher means we expect null value
            if (node.source !== null) {
                return false;
            }
        }
        else if (!this.source.matchValue(node.source, [...keys, 'source'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareExportDeclarationMatcher = DeclareExportDeclarationMatcher;
function declareExportDeclaration(declaration, specifiers, source) {
    return new DeclareExportDeclarationMatcher(declaration, specifiers, source);
}
exports.declareExportDeclaration = declareExportDeclaration;
class DeclareFunctionMatcher extends Matcher_1.Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareFunction(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareFunctionMatcher = DeclareFunctionMatcher;
function declareFunction(id) {
    return new DeclareFunctionMatcher(id);
}
exports.declareFunction = declareFunction;
class DeclareInterfaceMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, _extends, body) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this._extends = _extends;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareInterface(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this._extends === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._extends === null) {
            // null matcher means we expect null value
            if (node.extends !== null) {
                return false;
            }
        }
        else if (Array.isArray(this._extends)) {
            if (!(0, tupleOf_1.tupleOf)(...this._extends).matchValue(node.extends, [
                ...keys,
                'extends',
            ])) {
                return false;
            }
        }
        else if (!this._extends.matchValue(node.extends, [...keys, 'extends'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareInterfaceMatcher = DeclareInterfaceMatcher;
function declareInterface(id, typeParameters, _extends, body) {
    return new DeclareInterfaceMatcher(id, typeParameters, _extends, body);
}
exports.declareInterface = declareInterface;
class DeclareModuleMatcher extends Matcher_1.Matcher {
    constructor(id, body, kind) {
        super();
        this.id = id;
        this.body = body;
        this.kind = kind;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareModule(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.kind === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.kind === 'string') {
            if (this.kind !== node.kind) {
                return false;
            }
        }
        else if (this.kind === null) {
            // null matcher means we expect null value
            if (node.kind !== null) {
                return false;
            }
        }
        else if (!this.kind.matchValue(node.kind, [...keys, 'kind'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareModuleMatcher = DeclareModuleMatcher;
function declareModule(id, body, kind) {
    return new DeclareModuleMatcher(id, body, kind);
}
exports.declareModule = declareModule;
class DeclareModuleExportsMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareModuleExports(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.DeclareModuleExportsMatcher = DeclareModuleExportsMatcher;
function declareModuleExports(typeAnnotation) {
    return new DeclareModuleExportsMatcher(typeAnnotation);
}
exports.declareModuleExports = declareModuleExports;
class DeclareOpaqueTypeMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, supertype) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this.supertype = supertype;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareOpaqueType(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.supertype === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.supertype === null) {
            // null matcher means we expect null value
            if (node.supertype !== null) {
                return false;
            }
        }
        else if (!this.supertype.matchValue(node.supertype, [...keys, 'supertype'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareOpaqueTypeMatcher = DeclareOpaqueTypeMatcher;
function declareOpaqueType(id, typeParameters, supertype) {
    return new DeclareOpaqueTypeMatcher(id, typeParameters, supertype);
}
exports.declareOpaqueType = declareOpaqueType;
class DeclareTypeAliasMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, right) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareTypeAlias(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareTypeAliasMatcher = DeclareTypeAliasMatcher;
function declareTypeAlias(id, typeParameters, right) {
    return new DeclareTypeAliasMatcher(id, typeParameters, right);
}
exports.declareTypeAlias = declareTypeAlias;
class DeclareVariableMatcher extends Matcher_1.Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclareVariable(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        return true;
    }
}
exports.DeclareVariableMatcher = DeclareVariableMatcher;
function declareVariable(id) {
    return new DeclareVariableMatcher(id);
}
exports.declareVariable = declareVariable;
class DeclaredPredicateMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDeclaredPredicate(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.DeclaredPredicateMatcher = DeclaredPredicateMatcher;
function declaredPredicate(value) {
    return new DeclaredPredicateMatcher(value);
}
exports.declaredPredicate = declaredPredicate;
class DecoratorMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDecorator(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.DecoratorMatcher = DecoratorMatcher;
function decorator(expression) {
    return new DecoratorMatcher(expression);
}
exports.decorator = decorator;
class DirectiveMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDirective(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.DirectiveMatcher = DirectiveMatcher;
function directive(value) {
    return new DirectiveMatcher(value);
}
exports.directive = directive;
class DirectiveLiteralMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDirectiveLiteral(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.DirectiveLiteralMatcher = DirectiveLiteralMatcher;
function directiveLiteral(value) {
    return new DirectiveLiteralMatcher(value);
}
exports.directiveLiteral = directiveLiteral;
class DoExpressionMatcher extends Matcher_1.Matcher {
    constructor(body, async) {
        super();
        this.body = body;
        this.async = async;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDoExpression(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.async === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.async === 'boolean') {
            if (this.async !== node.async) {
                return false;
            }
        }
        else if (!this.async.matchValue(node.async, [...keys, 'async'])) {
            return false;
        }
        return true;
    }
}
exports.DoExpressionMatcher = DoExpressionMatcher;
function doExpression(body, async) {
    return new DoExpressionMatcher(body, async);
}
exports.doExpression = doExpression;
class DoWhileStatementMatcher extends Matcher_1.Matcher {
    constructor(test, body) {
        super();
        this.test = test;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isDoWhileStatement(node)) {
            return false;
        }
        if (typeof this.test === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.test.matchValue(node.test, [...keys, 'test'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.DoWhileStatementMatcher = DoWhileStatementMatcher;
function doWhileStatement(test, body) {
    return new DoWhileStatementMatcher(test, body);
}
exports.doWhileStatement = doWhileStatement;
class EmptyStatementMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEmptyStatement(node)) {
            return false;
        }
        return true;
    }
}
exports.EmptyStatementMatcher = EmptyStatementMatcher;
function emptyStatement() {
    return new EmptyStatementMatcher();
}
exports.emptyStatement = emptyStatement;
class EmptyTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEmptyTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.EmptyTypeAnnotationMatcher = EmptyTypeAnnotationMatcher;
function emptyTypeAnnotation() {
    return new EmptyTypeAnnotationMatcher();
}
exports.emptyTypeAnnotation = emptyTypeAnnotation;
class EnumBooleanBodyMatcher extends Matcher_1.Matcher {
    constructor(members) {
        super();
        this.members = members;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumBooleanBody(node)) {
            return false;
        }
        if (typeof this.members === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.members)) {
            if (!(0, tupleOf_1.tupleOf)(...this.members).matchValue(node.members, [
                ...keys,
                'members',
            ])) {
                return false;
            }
        }
        else if (!this.members.matchValue(node.members, [...keys, 'members'])) {
            return false;
        }
        return true;
    }
}
exports.EnumBooleanBodyMatcher = EnumBooleanBodyMatcher;
function enumBooleanBody(members) {
    return new EnumBooleanBodyMatcher(members);
}
exports.enumBooleanBody = enumBooleanBody;
class EnumBooleanMemberMatcher extends Matcher_1.Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumBooleanMember(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        return true;
    }
}
exports.EnumBooleanMemberMatcher = EnumBooleanMemberMatcher;
function enumBooleanMember(id) {
    return new EnumBooleanMemberMatcher(id);
}
exports.enumBooleanMember = enumBooleanMember;
class EnumDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, body) {
        super();
        this.id = id;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.EnumDeclarationMatcher = EnumDeclarationMatcher;
function enumDeclaration(id, body) {
    return new EnumDeclarationMatcher(id, body);
}
exports.enumDeclaration = enumDeclaration;
class EnumDefaultedMemberMatcher extends Matcher_1.Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumDefaultedMember(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        return true;
    }
}
exports.EnumDefaultedMemberMatcher = EnumDefaultedMemberMatcher;
function enumDefaultedMember(id) {
    return new EnumDefaultedMemberMatcher(id);
}
exports.enumDefaultedMember = enumDefaultedMember;
class EnumNumberBodyMatcher extends Matcher_1.Matcher {
    constructor(members) {
        super();
        this.members = members;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumNumberBody(node)) {
            return false;
        }
        if (typeof this.members === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.members)) {
            if (!(0, tupleOf_1.tupleOf)(...this.members).matchValue(node.members, [
                ...keys,
                'members',
            ])) {
                return false;
            }
        }
        else if (!this.members.matchValue(node.members, [...keys, 'members'])) {
            return false;
        }
        return true;
    }
}
exports.EnumNumberBodyMatcher = EnumNumberBodyMatcher;
function enumNumberBody(members) {
    return new EnumNumberBodyMatcher(members);
}
exports.enumNumberBody = enumNumberBody;
class EnumNumberMemberMatcher extends Matcher_1.Matcher {
    constructor(id, init) {
        super();
        this.id = id;
        this.init = init;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumNumberMember(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.init === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.init.matchValue(node.init, [...keys, 'init'])) {
            return false;
        }
        return true;
    }
}
exports.EnumNumberMemberMatcher = EnumNumberMemberMatcher;
function enumNumberMember(id, init) {
    return new EnumNumberMemberMatcher(id, init);
}
exports.enumNumberMember = enumNumberMember;
class EnumStringBodyMatcher extends Matcher_1.Matcher {
    constructor(members) {
        super();
        this.members = members;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumStringBody(node)) {
            return false;
        }
        if (typeof this.members === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.members)) {
            if (!(0, tupleOf_1.tupleOf)(...this.members).matchValue(node.members, [
                ...keys,
                'members',
            ])) {
                return false;
            }
        }
        else if (!this.members.matchValue(node.members, [...keys, 'members'])) {
            return false;
        }
        return true;
    }
}
exports.EnumStringBodyMatcher = EnumStringBodyMatcher;
function enumStringBody(members) {
    return new EnumStringBodyMatcher(members);
}
exports.enumStringBody = enumStringBody;
class EnumStringMemberMatcher extends Matcher_1.Matcher {
    constructor(id, init) {
        super();
        this.id = id;
        this.init = init;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumStringMember(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.init === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.init.matchValue(node.init, [...keys, 'init'])) {
            return false;
        }
        return true;
    }
}
exports.EnumStringMemberMatcher = EnumStringMemberMatcher;
function enumStringMember(id, init) {
    return new EnumStringMemberMatcher(id, init);
}
exports.enumStringMember = enumStringMember;
class EnumSymbolBodyMatcher extends Matcher_1.Matcher {
    constructor(members) {
        super();
        this.members = members;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isEnumSymbolBody(node)) {
            return false;
        }
        if (typeof this.members === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.members)) {
            if (!(0, tupleOf_1.tupleOf)(...this.members).matchValue(node.members, [
                ...keys,
                'members',
            ])) {
                return false;
            }
        }
        else if (!this.members.matchValue(node.members, [...keys, 'members'])) {
            return false;
        }
        return true;
    }
}
exports.EnumSymbolBodyMatcher = EnumSymbolBodyMatcher;
function enumSymbolBody(members) {
    return new EnumSymbolBodyMatcher(members);
}
exports.enumSymbolBody = enumSymbolBody;
class ExistsTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExistsTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.ExistsTypeAnnotationMatcher = ExistsTypeAnnotationMatcher;
function existsTypeAnnotation() {
    return new ExistsTypeAnnotationMatcher();
}
exports.existsTypeAnnotation = existsTypeAnnotation;
class ExportAllDeclarationMatcher extends Matcher_1.Matcher {
    constructor(source) {
        super();
        this.source = source;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExportAllDeclaration(node)) {
            return false;
        }
        if (typeof this.source === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.source.matchValue(node.source, [...keys, 'source'])) {
            return false;
        }
        return true;
    }
}
exports.ExportAllDeclarationMatcher = ExportAllDeclarationMatcher;
function exportAllDeclaration(source) {
    return new ExportAllDeclarationMatcher(source);
}
exports.exportAllDeclaration = exportAllDeclaration;
class ExportDefaultDeclarationMatcher extends Matcher_1.Matcher {
    constructor(declaration) {
        super();
        this.declaration = declaration;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExportDefaultDeclaration(node)) {
            return false;
        }
        if (typeof this.declaration === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.declaration.matchValue(node.declaration, [...keys, 'declaration'])) {
            return false;
        }
        return true;
    }
}
exports.ExportDefaultDeclarationMatcher = ExportDefaultDeclarationMatcher;
function exportDefaultDeclaration(declaration) {
    return new ExportDefaultDeclarationMatcher(declaration);
}
exports.exportDefaultDeclaration = exportDefaultDeclaration;
class ExportDefaultSpecifierMatcher extends Matcher_1.Matcher {
    constructor(exported) {
        super();
        this.exported = exported;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExportDefaultSpecifier(node)) {
            return false;
        }
        if (typeof this.exported === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.exported.matchValue(node.exported, [...keys, 'exported'])) {
            return false;
        }
        return true;
    }
}
exports.ExportDefaultSpecifierMatcher = ExportDefaultSpecifierMatcher;
function exportDefaultSpecifier(exported) {
    return new ExportDefaultSpecifierMatcher(exported);
}
exports.exportDefaultSpecifier = exportDefaultSpecifier;
class ExportNamedDeclarationMatcher extends Matcher_1.Matcher {
    constructor(declaration, specifiers, source) {
        super();
        this.declaration = declaration;
        this.specifiers = specifiers;
        this.source = source;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExportNamedDeclaration(node)) {
            return false;
        }
        if (typeof this.declaration === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.declaration === null) {
            // null matcher means we expect null value
            if (node.declaration !== null) {
                return false;
            }
        }
        else if (!this.declaration.matchValue(node.declaration, [...keys, 'declaration'])) {
            return false;
        }
        if (typeof this.specifiers === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.specifiers)) {
            if (!(0, tupleOf_1.tupleOf)(...this.specifiers).matchValue(node.specifiers, [
                ...keys,
                'specifiers',
            ])) {
                return false;
            }
        }
        else if (!this.specifiers.matchValue(node.specifiers, [...keys, 'specifiers'])) {
            return false;
        }
        if (typeof this.source === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.source === null) {
            // null matcher means we expect null value
            if (node.source !== null) {
                return false;
            }
        }
        else if (!this.source.matchValue(node.source, [...keys, 'source'])) {
            return false;
        }
        return true;
    }
}
exports.ExportNamedDeclarationMatcher = ExportNamedDeclarationMatcher;
function exportNamedDeclaration(declaration, specifiers, source) {
    return new ExportNamedDeclarationMatcher(declaration, specifiers, source);
}
exports.exportNamedDeclaration = exportNamedDeclaration;
class ExportNamespaceSpecifierMatcher extends Matcher_1.Matcher {
    constructor(exported) {
        super();
        this.exported = exported;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExportNamespaceSpecifier(node)) {
            return false;
        }
        if (typeof this.exported === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.exported.matchValue(node.exported, [...keys, 'exported'])) {
            return false;
        }
        return true;
    }
}
exports.ExportNamespaceSpecifierMatcher = ExportNamespaceSpecifierMatcher;
function exportNamespaceSpecifier(exported) {
    return new ExportNamespaceSpecifierMatcher(exported);
}
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
class ExportSpecifierMatcher extends Matcher_1.Matcher {
    constructor(local, exported) {
        super();
        this.local = local;
        this.exported = exported;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExportSpecifier(node)) {
            return false;
        }
        if (typeof this.local === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.local.matchValue(node.local, [...keys, 'local'])) {
            return false;
        }
        if (typeof this.exported === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.exported.matchValue(node.exported, [...keys, 'exported'])) {
            return false;
        }
        return true;
    }
}
exports.ExportSpecifierMatcher = ExportSpecifierMatcher;
function exportSpecifier(local, exported) {
    return new ExportSpecifierMatcher(local, exported);
}
exports.exportSpecifier = exportSpecifier;
class ExpressionStatementMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isExpressionStatement(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.ExpressionStatementMatcher = ExpressionStatementMatcher;
function expressionStatement(expression) {
    return new ExpressionStatementMatcher(expression);
}
exports.expressionStatement = expressionStatement;
class FileMatcher extends Matcher_1.Matcher {
    constructor(program, comments, tokens) {
        super();
        this.program = program;
        this.comments = comments;
        this.tokens = tokens;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isFile(node)) {
            return false;
        }
        if (typeof this.program === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.program.matchValue(node.program, [...keys, 'program'])) {
            return false;
        }
        if (typeof this.comments === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.comments === null) {
            // null matcher means we expect null value
            if (node.comments !== null) {
                return false;
            }
        }
        else if (!this.comments.matchValue(node.comments, [...keys, 'comments'])) {
            return false;
        }
        if (typeof this.tokens === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.tokens === null) {
            // null matcher means we expect null value
            if (node.tokens !== null) {
                return false;
            }
        }
        else if (!this.tokens.matchValue(node.tokens, [...keys, 'tokens'])) {
            return false;
        }
        return true;
    }
}
exports.FileMatcher = FileMatcher;
function file(program, comments, tokens) {
    return new FileMatcher(program, comments, tokens);
}
exports.file = file;
class ForInStatementMatcher extends Matcher_1.Matcher {
    constructor(left, right, body) {
        super();
        this.left = left;
        this.right = right;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isForInStatement(node)) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.ForInStatementMatcher = ForInStatementMatcher;
function forInStatement(left, right, body) {
    return new ForInStatementMatcher(left, right, body);
}
exports.forInStatement = forInStatement;
class ForOfStatementMatcher extends Matcher_1.Matcher {
    constructor(left, right, body, _await) {
        super();
        this.left = left;
        this.right = right;
        this.body = body;
        this._await = _await;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isForOfStatement(node)) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this._await === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._await === 'boolean') {
            if (this._await !== node.await) {
                return false;
            }
        }
        else if (!this._await.matchValue(node.await, [...keys, 'await'])) {
            return false;
        }
        return true;
    }
}
exports.ForOfStatementMatcher = ForOfStatementMatcher;
function forOfStatement(left, right, body, _await) {
    return new ForOfStatementMatcher(left, right, body, _await);
}
exports.forOfStatement = forOfStatement;
class ForStatementMatcher extends Matcher_1.Matcher {
    constructor(init, test, update, body) {
        super();
        this.init = init;
        this.test = test;
        this.update = update;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isForStatement(node)) {
            return false;
        }
        if (typeof this.init === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.init === null) {
            // null matcher means we expect null value
            if (node.init !== null) {
                return false;
            }
        }
        else if (!this.init.matchValue(node.init, [...keys, 'init'])) {
            return false;
        }
        if (typeof this.test === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.test === null) {
            // null matcher means we expect null value
            if (node.test !== null) {
                return false;
            }
        }
        else if (!this.test.matchValue(node.test, [...keys, 'test'])) {
            return false;
        }
        if (typeof this.update === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.update === null) {
            // null matcher means we expect null value
            if (node.update !== null) {
                return false;
            }
        }
        else if (!this.update.matchValue(node.update, [...keys, 'update'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.ForStatementMatcher = ForStatementMatcher;
function forStatement(init, test, update, body) {
    return new ForStatementMatcher(init, test, update, body);
}
exports.forStatement = forStatement;
class FunctionDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, params, body, generator, async) {
        super();
        this.id = id;
        this.params = params;
        this.body = body;
        this.generator = generator;
        this.async = async;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isFunctionDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.id === null) {
            // null matcher means we expect null value
            if (node.id !== null) {
                return false;
            }
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.generator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.generator === 'boolean') {
            if (this.generator !== node.generator) {
                return false;
            }
        }
        else if (!this.generator.matchValue(node.generator, [...keys, 'generator'])) {
            return false;
        }
        if (typeof this.async === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.async === 'boolean') {
            if (this.async !== node.async) {
                return false;
            }
        }
        else if (!this.async.matchValue(node.async, [...keys, 'async'])) {
            return false;
        }
        return true;
    }
}
exports.FunctionDeclarationMatcher = FunctionDeclarationMatcher;
function functionDeclaration(id, params, body, generator, async) {
    return new FunctionDeclarationMatcher(id, params, body, generator, async);
}
exports.functionDeclaration = functionDeclaration;
class FunctionExpressionMatcher extends Matcher_1.Matcher {
    constructor(id, params, body, generator, async) {
        super();
        this.id = id;
        this.params = params;
        this.body = body;
        this.generator = generator;
        this.async = async;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isFunctionExpression(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.id === null) {
            // null matcher means we expect null value
            if (node.id !== null) {
                return false;
            }
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.generator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.generator === 'boolean') {
            if (this.generator !== node.generator) {
                return false;
            }
        }
        else if (!this.generator.matchValue(node.generator, [...keys, 'generator'])) {
            return false;
        }
        if (typeof this.async === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.async === 'boolean') {
            if (this.async !== node.async) {
                return false;
            }
        }
        else if (!this.async.matchValue(node.async, [...keys, 'async'])) {
            return false;
        }
        return true;
    }
}
exports.FunctionExpressionMatcher = FunctionExpressionMatcher;
function functionExpression(id, params, body, generator, async) {
    return new FunctionExpressionMatcher(id, params, body, generator, async);
}
exports.functionExpression = functionExpression;
class FunctionTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(typeParameters, params, rest, returnType) {
        super();
        this.typeParameters = typeParameters;
        this.params = params;
        this.rest = rest;
        this.returnType = returnType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isFunctionTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.rest === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.rest === null) {
            // null matcher means we expect null value
            if (node.rest !== null) {
                return false;
            }
        }
        else if (!this.rest.matchValue(node.rest, [...keys, 'rest'])) {
            return false;
        }
        if (typeof this.returnType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.returnType.matchValue(node.returnType, [...keys, 'returnType'])) {
            return false;
        }
        return true;
    }
}
exports.FunctionTypeAnnotationMatcher = FunctionTypeAnnotationMatcher;
function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return new FunctionTypeAnnotationMatcher(typeParameters, params, rest, returnType);
}
exports.functionTypeAnnotation = functionTypeAnnotation;
class FunctionTypeParamMatcher extends Matcher_1.Matcher {
    constructor(name, typeAnnotation) {
        super();
        this.name = name;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isFunctionTypeParam(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.name === null) {
            // null matcher means we expect null value
            if (node.name !== null) {
                return false;
            }
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.FunctionTypeParamMatcher = FunctionTypeParamMatcher;
function functionTypeParam(name, typeAnnotation) {
    return new FunctionTypeParamMatcher(name, typeAnnotation);
}
exports.functionTypeParam = functionTypeParam;
class GenericTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isGenericTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.GenericTypeAnnotationMatcher = GenericTypeAnnotationMatcher;
function genericTypeAnnotation(id, typeParameters) {
    return new GenericTypeAnnotationMatcher(id, typeParameters);
}
exports.genericTypeAnnotation = genericTypeAnnotation;
class IdentifierMatcher extends Matcher_1.Matcher {
    constructor(name) {
        super();
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isIdentifier(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.name === 'string') {
            if (this.name !== node.name) {
                return false;
            }
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.IdentifierMatcher = IdentifierMatcher;
function identifier(name) {
    return new IdentifierMatcher(name);
}
exports.identifier = identifier;
class IfStatementMatcher extends Matcher_1.Matcher {
    constructor(test, consequent, alternate) {
        super();
        this.test = test;
        this.consequent = consequent;
        this.alternate = alternate;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isIfStatement(node)) {
            return false;
        }
        if (typeof this.test === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.test.matchValue(node.test, [...keys, 'test'])) {
            return false;
        }
        if (typeof this.consequent === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.consequent.matchValue(node.consequent, [...keys, 'consequent'])) {
            return false;
        }
        if (typeof this.alternate === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.alternate === null) {
            // null matcher means we expect null value
            if (node.alternate !== null) {
                return false;
            }
        }
        else if (!this.alternate.matchValue(node.alternate, [...keys, 'alternate'])) {
            return false;
        }
        return true;
    }
}
exports.IfStatementMatcher = IfStatementMatcher;
function ifStatement(test, consequent, alternate) {
    return new IfStatementMatcher(test, consequent, alternate);
}
exports.ifStatement = ifStatement;
class ImportMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isImport(node)) {
            return false;
        }
        return true;
    }
}
exports.ImportMatcher = ImportMatcher;
function Import() {
    return new ImportMatcher();
}
exports.Import = Import;
exports.import = Import;
class ImportAttributeMatcher extends Matcher_1.Matcher {
    constructor(key, value) {
        super();
        this.key = key;
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isImportAttribute(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.ImportAttributeMatcher = ImportAttributeMatcher;
function importAttribute(key, value) {
    return new ImportAttributeMatcher(key, value);
}
exports.importAttribute = importAttribute;
class ImportDeclarationMatcher extends Matcher_1.Matcher {
    constructor(specifiers, source) {
        super();
        this.specifiers = specifiers;
        this.source = source;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isImportDeclaration(node)) {
            return false;
        }
        if (typeof this.specifiers === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.specifiers)) {
            if (!(0, tupleOf_1.tupleOf)(...this.specifiers).matchValue(node.specifiers, [
                ...keys,
                'specifiers',
            ])) {
                return false;
            }
        }
        else if (!this.specifiers.matchValue(node.specifiers, [...keys, 'specifiers'])) {
            return false;
        }
        if (typeof this.source === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.source.matchValue(node.source, [...keys, 'source'])) {
            return false;
        }
        return true;
    }
}
exports.ImportDeclarationMatcher = ImportDeclarationMatcher;
function importDeclaration(specifiers, source) {
    return new ImportDeclarationMatcher(specifiers, source);
}
exports.importDeclaration = importDeclaration;
class ImportDefaultSpecifierMatcher extends Matcher_1.Matcher {
    constructor(local) {
        super();
        this.local = local;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isImportDefaultSpecifier(node)) {
            return false;
        }
        if (typeof this.local === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.local.matchValue(node.local, [...keys, 'local'])) {
            return false;
        }
        return true;
    }
}
exports.ImportDefaultSpecifierMatcher = ImportDefaultSpecifierMatcher;
function importDefaultSpecifier(local) {
    return new ImportDefaultSpecifierMatcher(local);
}
exports.importDefaultSpecifier = importDefaultSpecifier;
class ImportNamespaceSpecifierMatcher extends Matcher_1.Matcher {
    constructor(local) {
        super();
        this.local = local;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isImportNamespaceSpecifier(node)) {
            return false;
        }
        if (typeof this.local === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.local.matchValue(node.local, [...keys, 'local'])) {
            return false;
        }
        return true;
    }
}
exports.ImportNamespaceSpecifierMatcher = ImportNamespaceSpecifierMatcher;
function importNamespaceSpecifier(local) {
    return new ImportNamespaceSpecifierMatcher(local);
}
exports.importNamespaceSpecifier = importNamespaceSpecifier;
class ImportSpecifierMatcher extends Matcher_1.Matcher {
    constructor(local, imported) {
        super();
        this.local = local;
        this.imported = imported;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isImportSpecifier(node)) {
            return false;
        }
        if (typeof this.local === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.local.matchValue(node.local, [...keys, 'local'])) {
            return false;
        }
        if (typeof this.imported === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.imported.matchValue(node.imported, [...keys, 'imported'])) {
            return false;
        }
        return true;
    }
}
exports.ImportSpecifierMatcher = ImportSpecifierMatcher;
function importSpecifier(local, imported) {
    return new ImportSpecifierMatcher(local, imported);
}
exports.importSpecifier = importSpecifier;
class IndexedAccessTypeMatcher extends Matcher_1.Matcher {
    constructor(objectType, indexType) {
        super();
        this.objectType = objectType;
        this.indexType = indexType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isIndexedAccessType(node)) {
            return false;
        }
        if (typeof this.objectType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.objectType.matchValue(node.objectType, [...keys, 'objectType'])) {
            return false;
        }
        if (typeof this.indexType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.indexType.matchValue(node.indexType, [...keys, 'indexType'])) {
            return false;
        }
        return true;
    }
}
exports.IndexedAccessTypeMatcher = IndexedAccessTypeMatcher;
function indexedAccessType(objectType, indexType) {
    return new IndexedAccessTypeMatcher(objectType, indexType);
}
exports.indexedAccessType = indexedAccessType;
class InferredPredicateMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isInferredPredicate(node)) {
            return false;
        }
        return true;
    }
}
exports.InferredPredicateMatcher = InferredPredicateMatcher;
function inferredPredicate() {
    return new InferredPredicateMatcher();
}
exports.inferredPredicate = inferredPredicate;
class InterfaceDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, _extends, body) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this._extends = _extends;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isInterfaceDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this._extends === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._extends === null) {
            // null matcher means we expect null value
            if (node.extends !== null) {
                return false;
            }
        }
        else if (Array.isArray(this._extends)) {
            if (!(0, tupleOf_1.tupleOf)(...this._extends).matchValue(node.extends, [
                ...keys,
                'extends',
            ])) {
                return false;
            }
        }
        else if (!this._extends.matchValue(node.extends, [...keys, 'extends'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.InterfaceDeclarationMatcher = InterfaceDeclarationMatcher;
function interfaceDeclaration(id, typeParameters, _extends, body) {
    return new InterfaceDeclarationMatcher(id, typeParameters, _extends, body);
}
exports.interfaceDeclaration = interfaceDeclaration;
class InterfaceExtendsMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isInterfaceExtends(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.InterfaceExtendsMatcher = InterfaceExtendsMatcher;
function interfaceExtends(id, typeParameters) {
    return new InterfaceExtendsMatcher(id, typeParameters);
}
exports.interfaceExtends = interfaceExtends;
class InterfaceTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(_extends, body) {
        super();
        this._extends = _extends;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isInterfaceTypeAnnotation(node)) {
            return false;
        }
        if (typeof this._extends === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._extends === null) {
            // null matcher means we expect null value
            if (node.extends !== null) {
                return false;
            }
        }
        else if (Array.isArray(this._extends)) {
            if (!(0, tupleOf_1.tupleOf)(...this._extends).matchValue(node.extends, [
                ...keys,
                'extends',
            ])) {
                return false;
            }
        }
        else if (!this._extends.matchValue(node.extends, [...keys, 'extends'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.InterfaceTypeAnnotationMatcher = InterfaceTypeAnnotationMatcher;
function interfaceTypeAnnotation(_extends, body) {
    return new InterfaceTypeAnnotationMatcher(_extends, body);
}
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
class InterpreterDirectiveMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isInterpreterDirective(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.InterpreterDirectiveMatcher = InterpreterDirectiveMatcher;
function interpreterDirective(value) {
    return new InterpreterDirectiveMatcher(value);
}
exports.interpreterDirective = interpreterDirective;
class IntersectionTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(types) {
        super();
        this.types = types;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isIntersectionTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.types === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.types)) {
            if (!(0, tupleOf_1.tupleOf)(...this.types).matchValue(node.types, [
                ...keys,
                'types',
            ])) {
                return false;
            }
        }
        else if (!this.types.matchValue(node.types, [...keys, 'types'])) {
            return false;
        }
        return true;
    }
}
exports.IntersectionTypeAnnotationMatcher = IntersectionTypeAnnotationMatcher;
function intersectionTypeAnnotation(types) {
    return new IntersectionTypeAnnotationMatcher(types);
}
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
class JSXAttributeMatcher extends Matcher_1.Matcher {
    constructor(name, value) {
        super();
        this.name = name;
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXAttribute(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.value === null) {
            // null matcher means we expect null value
            if (node.value !== null) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.JSXAttributeMatcher = JSXAttributeMatcher;
function jsxAttribute(name, value) {
    return new JSXAttributeMatcher(name, value);
}
exports.jsxAttribute = jsxAttribute;
class JSXClosingElementMatcher extends Matcher_1.Matcher {
    constructor(name) {
        super();
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXClosingElement(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.JSXClosingElementMatcher = JSXClosingElementMatcher;
function jsxClosingElement(name) {
    return new JSXClosingElementMatcher(name);
}
exports.jsxClosingElement = jsxClosingElement;
class JSXClosingFragmentMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXClosingFragment(node)) {
            return false;
        }
        return true;
    }
}
exports.JSXClosingFragmentMatcher = JSXClosingFragmentMatcher;
function jsxClosingFragment() {
    return new JSXClosingFragmentMatcher();
}
exports.jsxClosingFragment = jsxClosingFragment;
class JSXElementMatcher extends Matcher_1.Matcher {
    constructor(openingElement, closingElement, children, selfClosing) {
        super();
        this.openingElement = openingElement;
        this.closingElement = closingElement;
        this.children = children;
        this.selfClosing = selfClosing;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXElement(node)) {
            return false;
        }
        if (typeof this.openingElement === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.openingElement.matchValue(node.openingElement, [
            ...keys,
            'openingElement',
        ])) {
            return false;
        }
        if (typeof this.closingElement === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.closingElement === null) {
            // null matcher means we expect null value
            if (node.closingElement !== null) {
                return false;
            }
        }
        else if (!this.closingElement.matchValue(node.closingElement, [
            ...keys,
            'closingElement',
        ])) {
            return false;
        }
        if (typeof this.children === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.children)) {
            if (!(0, tupleOf_1.tupleOf)(...this.children).matchValue(node.children, [
                ...keys,
                'children',
            ])) {
                return false;
            }
        }
        else if (!this.children.matchValue(node.children, [...keys, 'children'])) {
            return false;
        }
        if (typeof this.selfClosing === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.selfClosing === 'boolean') {
            if (this.selfClosing !== node.selfClosing) {
                return false;
            }
        }
        else if (this.selfClosing === null) {
            // null matcher means we expect null value
            if (node.selfClosing !== null) {
                return false;
            }
        }
        else if (!this.selfClosing.matchValue(node.selfClosing, [...keys, 'selfClosing'])) {
            return false;
        }
        return true;
    }
}
exports.JSXElementMatcher = JSXElementMatcher;
function jsxElement(openingElement, closingElement, children, selfClosing) {
    return new JSXElementMatcher(openingElement, closingElement, children, selfClosing);
}
exports.jsxElement = jsxElement;
class JSXEmptyExpressionMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXEmptyExpression(node)) {
            return false;
        }
        return true;
    }
}
exports.JSXEmptyExpressionMatcher = JSXEmptyExpressionMatcher;
function jsxEmptyExpression() {
    return new JSXEmptyExpressionMatcher();
}
exports.jsxEmptyExpression = jsxEmptyExpression;
class JSXExpressionContainerMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXExpressionContainer(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.JSXExpressionContainerMatcher = JSXExpressionContainerMatcher;
function jsxExpressionContainer(expression) {
    return new JSXExpressionContainerMatcher(expression);
}
exports.jsxExpressionContainer = jsxExpressionContainer;
class JSXFragmentMatcher extends Matcher_1.Matcher {
    constructor(openingFragment, closingFragment, children) {
        super();
        this.openingFragment = openingFragment;
        this.closingFragment = closingFragment;
        this.children = children;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXFragment(node)) {
            return false;
        }
        if (typeof this.openingFragment === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.openingFragment.matchValue(node.openingFragment, [
            ...keys,
            'openingFragment',
        ])) {
            return false;
        }
        if (typeof this.closingFragment === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.closingFragment.matchValue(node.closingFragment, [
            ...keys,
            'closingFragment',
        ])) {
            return false;
        }
        if (typeof this.children === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.children)) {
            if (!(0, tupleOf_1.tupleOf)(...this.children).matchValue(node.children, [
                ...keys,
                'children',
            ])) {
                return false;
            }
        }
        else if (!this.children.matchValue(node.children, [...keys, 'children'])) {
            return false;
        }
        return true;
    }
}
exports.JSXFragmentMatcher = JSXFragmentMatcher;
function jsxFragment(openingFragment, closingFragment, children) {
    return new JSXFragmentMatcher(openingFragment, closingFragment, children);
}
exports.jsxFragment = jsxFragment;
class JSXIdentifierMatcher extends Matcher_1.Matcher {
    constructor(name) {
        super();
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXIdentifier(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.name === 'string') {
            if (this.name !== node.name) {
                return false;
            }
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.JSXIdentifierMatcher = JSXIdentifierMatcher;
function jsxIdentifier(name) {
    return new JSXIdentifierMatcher(name);
}
exports.jsxIdentifier = jsxIdentifier;
class JSXMemberExpressionMatcher extends Matcher_1.Matcher {
    constructor(object, property) {
        super();
        this.object = object;
        this.property = property;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXMemberExpression(node)) {
            return false;
        }
        if (typeof this.object === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.object.matchValue(node.object, [...keys, 'object'])) {
            return false;
        }
        if (typeof this.property === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.property.matchValue(node.property, [...keys, 'property'])) {
            return false;
        }
        return true;
    }
}
exports.JSXMemberExpressionMatcher = JSXMemberExpressionMatcher;
function jsxMemberExpression(object, property) {
    return new JSXMemberExpressionMatcher(object, property);
}
exports.jsxMemberExpression = jsxMemberExpression;
class JSXNamespacedNameMatcher extends Matcher_1.Matcher {
    constructor(namespace, name) {
        super();
        this.namespace = namespace;
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXNamespacedName(node)) {
            return false;
        }
        if (typeof this.namespace === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.namespace.matchValue(node.namespace, [...keys, 'namespace'])) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.JSXNamespacedNameMatcher = JSXNamespacedNameMatcher;
function jsxNamespacedName(namespace, name) {
    return new JSXNamespacedNameMatcher(namespace, name);
}
exports.jsxNamespacedName = jsxNamespacedName;
class JSXOpeningElementMatcher extends Matcher_1.Matcher {
    constructor(name, attributes, selfClosing) {
        super();
        this.name = name;
        this.attributes = attributes;
        this.selfClosing = selfClosing;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXOpeningElement(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        if (typeof this.attributes === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.attributes)) {
            if (!(0, tupleOf_1.tupleOf)(...this.attributes).matchValue(node.attributes, [
                ...keys,
                'attributes',
            ])) {
                return false;
            }
        }
        else if (!this.attributes.matchValue(node.attributes, [...keys, 'attributes'])) {
            return false;
        }
        if (typeof this.selfClosing === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.selfClosing === 'boolean') {
            if (this.selfClosing !== node.selfClosing) {
                return false;
            }
        }
        else if (!this.selfClosing.matchValue(node.selfClosing, [...keys, 'selfClosing'])) {
            return false;
        }
        return true;
    }
}
exports.JSXOpeningElementMatcher = JSXOpeningElementMatcher;
function jsxOpeningElement(name, attributes, selfClosing) {
    return new JSXOpeningElementMatcher(name, attributes, selfClosing);
}
exports.jsxOpeningElement = jsxOpeningElement;
class JSXOpeningFragmentMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXOpeningFragment(node)) {
            return false;
        }
        return true;
    }
}
exports.JSXOpeningFragmentMatcher = JSXOpeningFragmentMatcher;
function jsxOpeningFragment() {
    return new JSXOpeningFragmentMatcher();
}
exports.jsxOpeningFragment = jsxOpeningFragment;
class JSXSpreadAttributeMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXSpreadAttribute(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.JSXSpreadAttributeMatcher = JSXSpreadAttributeMatcher;
function jsxSpreadAttribute(argument) {
    return new JSXSpreadAttributeMatcher(argument);
}
exports.jsxSpreadAttribute = jsxSpreadAttribute;
class JSXSpreadChildMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXSpreadChild(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.JSXSpreadChildMatcher = JSXSpreadChildMatcher;
function jsxSpreadChild(expression) {
    return new JSXSpreadChildMatcher(expression);
}
exports.jsxSpreadChild = jsxSpreadChild;
class JSXTextMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isJSXText(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.JSXTextMatcher = JSXTextMatcher;
function jsxText(value) {
    return new JSXTextMatcher(value);
}
exports.jsxText = jsxText;
class LabeledStatementMatcher extends Matcher_1.Matcher {
    constructor(label, body) {
        super();
        this.label = label;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isLabeledStatement(node)) {
            return false;
        }
        if (typeof this.label === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.label.matchValue(node.label, [...keys, 'label'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.LabeledStatementMatcher = LabeledStatementMatcher;
function labeledStatement(label, body) {
    return new LabeledStatementMatcher(label, body);
}
exports.labeledStatement = labeledStatement;
class LogicalExpressionMatcher extends Matcher_1.Matcher {
    constructor(operator, left, right) {
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isLogicalExpression(node)) {
            return false;
        }
        if (typeof this.operator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.operator === 'string') {
            if (this.operator !== node.operator) {
                return false;
            }
        }
        else if (!this.operator.matchValue(node.operator, [...keys, 'operator'])) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.LogicalExpressionMatcher = LogicalExpressionMatcher;
function logicalExpression(operator, left, right) {
    return new LogicalExpressionMatcher(operator, left, right);
}
exports.logicalExpression = logicalExpression;
class MemberExpressionMatcher extends Matcher_1.Matcher {
    constructor(object, property, computed, optional) {
        super();
        this.object = object;
        this.property = property;
        this.computed = computed;
        this.optional = optional;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isMemberExpression(node)) {
            return false;
        }
        if (typeof this.object === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.object.matchValue(node.object, [...keys, 'object'])) {
            return false;
        }
        if (typeof this.property === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.property.matchValue(node.property, [...keys, 'property'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this.optional === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.optional === 'boolean') {
            if (this.optional !== node.optional) {
                return false;
            }
        }
        else if (this.optional === null) {
            // null matcher means we expect null value
            if (node.optional !== null) {
                return false;
            }
        }
        else if (!this.optional.matchValue(node.optional, [...keys, 'optional'])) {
            return false;
        }
        return true;
    }
}
exports.MemberExpressionMatcher = MemberExpressionMatcher;
function memberExpression(object, property, computed, optional) {
    return new MemberExpressionMatcher(object, property, computed, optional);
}
exports.memberExpression = memberExpression;
class MetaPropertyMatcher extends Matcher_1.Matcher {
    constructor(meta, property) {
        super();
        this.meta = meta;
        this.property = property;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isMetaProperty(node)) {
            return false;
        }
        if (typeof this.meta === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.meta.matchValue(node.meta, [...keys, 'meta'])) {
            return false;
        }
        if (typeof this.property === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.property.matchValue(node.property, [...keys, 'property'])) {
            return false;
        }
        return true;
    }
}
exports.MetaPropertyMatcher = MetaPropertyMatcher;
function metaProperty(meta, property) {
    return new MetaPropertyMatcher(meta, property);
}
exports.metaProperty = metaProperty;
class MixedTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isMixedTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.MixedTypeAnnotationMatcher = MixedTypeAnnotationMatcher;
function mixedTypeAnnotation() {
    return new MixedTypeAnnotationMatcher();
}
exports.mixedTypeAnnotation = mixedTypeAnnotation;
class ModuleExpressionMatcher extends Matcher_1.Matcher {
    constructor(body) {
        super();
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isModuleExpression(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.ModuleExpressionMatcher = ModuleExpressionMatcher;
function moduleExpression(body) {
    return new ModuleExpressionMatcher(body);
}
exports.moduleExpression = moduleExpression;
class NewExpressionMatcher extends Matcher_1.Matcher {
    constructor(callee, _arguments) {
        super();
        this.callee = callee;
        this._arguments = _arguments;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNewExpression(node)) {
            return false;
        }
        if (typeof this.callee === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.callee.matchValue(node.callee, [...keys, 'callee'])) {
            return false;
        }
        if (typeof this._arguments === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this._arguments)) {
            if (!(0, tupleOf_1.tupleOf)(...this._arguments).matchValue(node.arguments, [
                ...keys,
                'arguments',
            ])) {
                return false;
            }
        }
        else if (!this._arguments.matchValue(node.arguments, [...keys, 'arguments'])) {
            return false;
        }
        return true;
    }
}
exports.NewExpressionMatcher = NewExpressionMatcher;
function newExpression(callee, _arguments) {
    return new NewExpressionMatcher(callee, _arguments);
}
exports.newExpression = newExpression;
class NoopMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNoop(node)) {
            return false;
        }
        return true;
    }
}
exports.NoopMatcher = NoopMatcher;
function noop() {
    return new NoopMatcher();
}
exports.noop = noop;
class NullLiteralMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNullLiteral(node)) {
            return false;
        }
        return true;
    }
}
exports.NullLiteralMatcher = NullLiteralMatcher;
function nullLiteral() {
    return new NullLiteralMatcher();
}
exports.nullLiteral = nullLiteral;
class NullLiteralTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNullLiteralTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.NullLiteralTypeAnnotationMatcher = NullLiteralTypeAnnotationMatcher;
function nullLiteralTypeAnnotation() {
    return new NullLiteralTypeAnnotationMatcher();
}
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
class NullableTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNullableTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.NullableTypeAnnotationMatcher = NullableTypeAnnotationMatcher;
function nullableTypeAnnotation(typeAnnotation) {
    return new NullableTypeAnnotationMatcher(typeAnnotation);
}
exports.nullableTypeAnnotation = nullableTypeAnnotation;
class NumberLiteralTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNumberLiteralTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'number') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.NumberLiteralTypeAnnotationMatcher = NumberLiteralTypeAnnotationMatcher;
function numberLiteralTypeAnnotation(value) {
    return new NumberLiteralTypeAnnotationMatcher(value);
}
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
class NumberTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNumberTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.NumberTypeAnnotationMatcher = NumberTypeAnnotationMatcher;
function numberTypeAnnotation() {
    return new NumberTypeAnnotationMatcher();
}
exports.numberTypeAnnotation = numberTypeAnnotation;
class NumericLiteralMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isNumericLiteral(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'number') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.NumericLiteralMatcher = NumericLiteralMatcher;
function numericLiteral(value) {
    return new NumericLiteralMatcher(value);
}
exports.numericLiteral = numericLiteral;
class ObjectExpressionMatcher extends Matcher_1.Matcher {
    constructor(properties) {
        super();
        this.properties = properties;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectExpression(node)) {
            return false;
        }
        if (typeof this.properties === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.properties)) {
            if (!(0, tupleOf_1.tupleOf)(...this.properties).matchValue(node.properties, [
                ...keys,
                'properties',
            ])) {
                return false;
            }
        }
        else if (!this.properties.matchValue(node.properties, [...keys, 'properties'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectExpressionMatcher = ObjectExpressionMatcher;
function objectExpression(properties) {
    return new ObjectExpressionMatcher(properties);
}
exports.objectExpression = objectExpression;
class ObjectMethodMatcher extends Matcher_1.Matcher {
    constructor(kind, key, params, body, computed, generator, async) {
        super();
        this.kind = kind;
        this.key = key;
        this.params = params;
        this.body = body;
        this.computed = computed;
        this.generator = generator;
        this.async = async;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectMethod(node)) {
            return false;
        }
        if (typeof this.kind === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.kind === 'string') {
            if (this.kind !== node.kind) {
                return false;
            }
        }
        else if (!this.kind.matchValue(node.kind, [...keys, 'kind'])) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this.generator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.generator === 'boolean') {
            if (this.generator !== node.generator) {
                return false;
            }
        }
        else if (!this.generator.matchValue(node.generator, [...keys, 'generator'])) {
            return false;
        }
        if (typeof this.async === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.async === 'boolean') {
            if (this.async !== node.async) {
                return false;
            }
        }
        else if (!this.async.matchValue(node.async, [...keys, 'async'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectMethodMatcher = ObjectMethodMatcher;
function objectMethod(kind, key, params, body, computed, generator, async) {
    return new ObjectMethodMatcher(kind, key, params, body, computed, generator, async);
}
exports.objectMethod = objectMethod;
class ObjectPatternMatcher extends Matcher_1.Matcher {
    constructor(properties) {
        super();
        this.properties = properties;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectPattern(node)) {
            return false;
        }
        if (typeof this.properties === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.properties)) {
            if (!(0, tupleOf_1.tupleOf)(...this.properties).matchValue(node.properties, [
                ...keys,
                'properties',
            ])) {
                return false;
            }
        }
        else if (!this.properties.matchValue(node.properties, [...keys, 'properties'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectPatternMatcher = ObjectPatternMatcher;
function objectPattern(properties) {
    return new ObjectPatternMatcher(properties);
}
exports.objectPattern = objectPattern;
class ObjectPropertyMatcher extends Matcher_1.Matcher {
    constructor(key, value, computed, shorthand, decorators) {
        super();
        this.key = key;
        this.value = value;
        this.computed = computed;
        this.shorthand = shorthand;
        this.decorators = decorators;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectProperty(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this.shorthand === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.shorthand === 'boolean') {
            if (this.shorthand !== node.shorthand) {
                return false;
            }
        }
        else if (!this.shorthand.matchValue(node.shorthand, [...keys, 'shorthand'])) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectPropertyMatcher = ObjectPropertyMatcher;
function objectProperty(key, value, computed, shorthand, decorators) {
    return new ObjectPropertyMatcher(key, value, computed, shorthand, decorators);
}
exports.objectProperty = objectProperty;
class ObjectTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(properties, indexers, callProperties, internalSlots, exact) {
        super();
        this.properties = properties;
        this.indexers = indexers;
        this.callProperties = callProperties;
        this.internalSlots = internalSlots;
        this.exact = exact;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.properties === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.properties)) {
            if (!(0, tupleOf_1.tupleOf)(...this.properties).matchValue(node.properties, [
                ...keys,
                'properties',
            ])) {
                return false;
            }
        }
        else if (!this.properties.matchValue(node.properties, [...keys, 'properties'])) {
            return false;
        }
        if (typeof this.indexers === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.indexers === null) {
            // null matcher means we expect null value
            if (node.indexers !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.indexers)) {
            if (!(0, tupleOf_1.tupleOf)(...this.indexers).matchValue(node.indexers, [
                ...keys,
                'indexers',
            ])) {
                return false;
            }
        }
        else if (!this.indexers.matchValue(node.indexers, [...keys, 'indexers'])) {
            return false;
        }
        if (typeof this.callProperties === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.callProperties === null) {
            // null matcher means we expect null value
            if (node.callProperties !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.callProperties)) {
            if (!(0, tupleOf_1.tupleOf)(...this.callProperties).matchValue(node.callProperties, [...keys, 'callProperties'])) {
                return false;
            }
        }
        else if (!this.callProperties.matchValue(node.callProperties, [
            ...keys,
            'callProperties',
        ])) {
            return false;
        }
        if (typeof this.internalSlots === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.internalSlots === null) {
            // null matcher means we expect null value
            if (node.internalSlots !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.internalSlots)) {
            if (!(0, tupleOf_1.tupleOf)(...this.internalSlots).matchValue(node.internalSlots, [...keys, 'internalSlots'])) {
                return false;
            }
        }
        else if (!this.internalSlots.matchValue(node.internalSlots, [
            ...keys,
            'internalSlots',
        ])) {
            return false;
        }
        if (typeof this.exact === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.exact === 'boolean') {
            if (this.exact !== node.exact) {
                return false;
            }
        }
        else if (!this.exact.matchValue(node.exact, [...keys, 'exact'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectTypeAnnotationMatcher = ObjectTypeAnnotationMatcher;
function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return new ObjectTypeAnnotationMatcher(properties, indexers, callProperties, internalSlots, exact);
}
exports.objectTypeAnnotation = objectTypeAnnotation;
class ObjectTypeCallPropertyMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectTypeCallProperty(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectTypeCallPropertyMatcher = ObjectTypeCallPropertyMatcher;
function objectTypeCallProperty(value) {
    return new ObjectTypeCallPropertyMatcher(value);
}
exports.objectTypeCallProperty = objectTypeCallProperty;
class ObjectTypeIndexerMatcher extends Matcher_1.Matcher {
    constructor(id, key, value, variance) {
        super();
        this.id = id;
        this.key = key;
        this.value = value;
        this.variance = variance;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectTypeIndexer(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.id === null) {
            // null matcher means we expect null value
            if (node.id !== null) {
                return false;
            }
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.variance === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.variance === null) {
            // null matcher means we expect null value
            if (node.variance !== null) {
                return false;
            }
        }
        else if (!this.variance.matchValue(node.variance, [...keys, 'variance'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectTypeIndexerMatcher = ObjectTypeIndexerMatcher;
function objectTypeIndexer(id, key, value, variance) {
    return new ObjectTypeIndexerMatcher(id, key, value, variance);
}
exports.objectTypeIndexer = objectTypeIndexer;
class ObjectTypeInternalSlotMatcher extends Matcher_1.Matcher {
    constructor(id, value, optional, _static, method) {
        super();
        this.id = id;
        this.value = value;
        this.optional = optional;
        this._static = _static;
        this.method = method;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectTypeInternalSlot(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.optional === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.optional === 'boolean') {
            if (this.optional !== node.optional) {
                return false;
            }
        }
        else if (!this.optional.matchValue(node.optional, [...keys, 'optional'])) {
            return false;
        }
        if (typeof this._static === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this._static === 'boolean') {
            if (this._static !== node.static) {
                return false;
            }
        }
        else if (!this._static.matchValue(node.static, [...keys, 'static'])) {
            return false;
        }
        if (typeof this.method === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.method === 'boolean') {
            if (this.method !== node.method) {
                return false;
            }
        }
        else if (!this.method.matchValue(node.method, [...keys, 'method'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectTypeInternalSlotMatcher = ObjectTypeInternalSlotMatcher;
function objectTypeInternalSlot(id, value, optional, _static, method) {
    return new ObjectTypeInternalSlotMatcher(id, value, optional, _static, method);
}
exports.objectTypeInternalSlot = objectTypeInternalSlot;
class ObjectTypePropertyMatcher extends Matcher_1.Matcher {
    constructor(key, value, variance) {
        super();
        this.key = key;
        this.value = value;
        this.variance = variance;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectTypeProperty(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.variance === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.variance === null) {
            // null matcher means we expect null value
            if (node.variance !== null) {
                return false;
            }
        }
        else if (!this.variance.matchValue(node.variance, [...keys, 'variance'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectTypePropertyMatcher = ObjectTypePropertyMatcher;
function objectTypeProperty(key, value, variance) {
    return new ObjectTypePropertyMatcher(key, value, variance);
}
exports.objectTypeProperty = objectTypeProperty;
class ObjectTypeSpreadPropertyMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isObjectTypeSpreadProperty(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.ObjectTypeSpreadPropertyMatcher = ObjectTypeSpreadPropertyMatcher;
function objectTypeSpreadProperty(argument) {
    return new ObjectTypeSpreadPropertyMatcher(argument);
}
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
class OpaqueTypeMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, supertype, impltype) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this.supertype = supertype;
        this.impltype = impltype;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isOpaqueType(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.supertype === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.supertype === null) {
            // null matcher means we expect null value
            if (node.supertype !== null) {
                return false;
            }
        }
        else if (!this.supertype.matchValue(node.supertype, [...keys, 'supertype'])) {
            return false;
        }
        if (typeof this.impltype === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.impltype.matchValue(node.impltype, [...keys, 'impltype'])) {
            return false;
        }
        return true;
    }
}
exports.OpaqueTypeMatcher = OpaqueTypeMatcher;
function opaqueType(id, typeParameters, supertype, impltype) {
    return new OpaqueTypeMatcher(id, typeParameters, supertype, impltype);
}
exports.opaqueType = opaqueType;
class OptionalCallExpressionMatcher extends Matcher_1.Matcher {
    constructor(callee, _arguments, optional) {
        super();
        this.callee = callee;
        this._arguments = _arguments;
        this.optional = optional;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isOptionalCallExpression(node)) {
            return false;
        }
        if (typeof this.callee === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.callee.matchValue(node.callee, [...keys, 'callee'])) {
            return false;
        }
        if (typeof this._arguments === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this._arguments)) {
            if (!(0, tupleOf_1.tupleOf)(...this._arguments).matchValue(node.arguments, [
                ...keys,
                'arguments',
            ])) {
                return false;
            }
        }
        else if (!this._arguments.matchValue(node.arguments, [...keys, 'arguments'])) {
            return false;
        }
        if (typeof this.optional === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.optional === 'boolean') {
            if (this.optional !== node.optional) {
                return false;
            }
        }
        else if (!this.optional.matchValue(node.optional, [...keys, 'optional'])) {
            return false;
        }
        return true;
    }
}
exports.OptionalCallExpressionMatcher = OptionalCallExpressionMatcher;
function optionalCallExpression(callee, _arguments, optional) {
    return new OptionalCallExpressionMatcher(callee, _arguments, optional);
}
exports.optionalCallExpression = optionalCallExpression;
class OptionalIndexedAccessTypeMatcher extends Matcher_1.Matcher {
    constructor(objectType, indexType) {
        super();
        this.objectType = objectType;
        this.indexType = indexType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isOptionalIndexedAccessType(node)) {
            return false;
        }
        if (typeof this.objectType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.objectType.matchValue(node.objectType, [...keys, 'objectType'])) {
            return false;
        }
        if (typeof this.indexType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.indexType.matchValue(node.indexType, [...keys, 'indexType'])) {
            return false;
        }
        return true;
    }
}
exports.OptionalIndexedAccessTypeMatcher = OptionalIndexedAccessTypeMatcher;
function optionalIndexedAccessType(objectType, indexType) {
    return new OptionalIndexedAccessTypeMatcher(objectType, indexType);
}
exports.optionalIndexedAccessType = optionalIndexedAccessType;
class OptionalMemberExpressionMatcher extends Matcher_1.Matcher {
    constructor(object, property, computed, optional) {
        super();
        this.object = object;
        this.property = property;
        this.computed = computed;
        this.optional = optional;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isOptionalMemberExpression(node)) {
            return false;
        }
        if (typeof this.object === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.object.matchValue(node.object, [...keys, 'object'])) {
            return false;
        }
        if (typeof this.property === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.property.matchValue(node.property, [...keys, 'property'])) {
            return false;
        }
        if (typeof this.computed === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.computed === 'boolean') {
            if (this.computed !== node.computed) {
                return false;
            }
        }
        else if (!this.computed.matchValue(node.computed, [...keys, 'computed'])) {
            return false;
        }
        if (typeof this.optional === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.optional === 'boolean') {
            if (this.optional !== node.optional) {
                return false;
            }
        }
        else if (!this.optional.matchValue(node.optional, [...keys, 'optional'])) {
            return false;
        }
        return true;
    }
}
exports.OptionalMemberExpressionMatcher = OptionalMemberExpressionMatcher;
function optionalMemberExpression(object, property, computed, optional) {
    return new OptionalMemberExpressionMatcher(object, property, computed, optional);
}
exports.optionalMemberExpression = optionalMemberExpression;
class ParenthesizedExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isParenthesizedExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.ParenthesizedExpressionMatcher = ParenthesizedExpressionMatcher;
function parenthesizedExpression(expression) {
    return new ParenthesizedExpressionMatcher(expression);
}
exports.parenthesizedExpression = parenthesizedExpression;
class PipelineBareFunctionMatcher extends Matcher_1.Matcher {
    constructor(callee) {
        super();
        this.callee = callee;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isPipelineBareFunction(node)) {
            return false;
        }
        if (typeof this.callee === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.callee.matchValue(node.callee, [...keys, 'callee'])) {
            return false;
        }
        return true;
    }
}
exports.PipelineBareFunctionMatcher = PipelineBareFunctionMatcher;
function pipelineBareFunction(callee) {
    return new PipelineBareFunctionMatcher(callee);
}
exports.pipelineBareFunction = pipelineBareFunction;
class PipelinePrimaryTopicReferenceMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isPipelinePrimaryTopicReference(node)) {
            return false;
        }
        return true;
    }
}
exports.PipelinePrimaryTopicReferenceMatcher = PipelinePrimaryTopicReferenceMatcher;
function pipelinePrimaryTopicReference() {
    return new PipelinePrimaryTopicReferenceMatcher();
}
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
class PipelineTopicExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isPipelineTopicExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.PipelineTopicExpressionMatcher = PipelineTopicExpressionMatcher;
function pipelineTopicExpression(expression) {
    return new PipelineTopicExpressionMatcher(expression);
}
exports.pipelineTopicExpression = pipelineTopicExpression;
class PlaceholderMatcher extends Matcher_1.Matcher {
    constructor(expectedNode, name) {
        super();
        this.expectedNode = expectedNode;
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isPlaceholder(node)) {
            return false;
        }
        if (typeof this.expectedNode === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.expectedNode === 'string') {
            if (this.expectedNode !== node.expectedNode) {
                return false;
            }
        }
        else if (!this.expectedNode.matchValue(node.expectedNode, [
            ...keys,
            'expectedNode',
        ])) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.PlaceholderMatcher = PlaceholderMatcher;
function placeholder(expectedNode, name) {
    return new PlaceholderMatcher(expectedNode, name);
}
exports.placeholder = placeholder;
class PrivateNameMatcher extends Matcher_1.Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isPrivateName(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        return true;
    }
}
exports.PrivateNameMatcher = PrivateNameMatcher;
function privateName(id) {
    return new PrivateNameMatcher(id);
}
exports.privateName = privateName;
class ProgramMatcher extends Matcher_1.Matcher {
    constructor(body, directives, sourceType, interpreter) {
        super();
        this.body = body;
        this.directives = directives;
        this.sourceType = sourceType;
        this.interpreter = interpreter;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isProgram(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.body)) {
            if (!(0, tupleOf_1.tupleOf)(...this.body).matchValue(node.body, [...keys, 'body'])) {
                return false;
            }
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        if (typeof this.directives === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.directives)) {
            if (!(0, tupleOf_1.tupleOf)(...this.directives).matchValue(node.directives, [
                ...keys,
                'directives',
            ])) {
                return false;
            }
        }
        else if (!this.directives.matchValue(node.directives, [...keys, 'directives'])) {
            return false;
        }
        if (typeof this.sourceType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.sourceType === 'string') {
            if (this.sourceType !== node.sourceType) {
                return false;
            }
        }
        else if (!this.sourceType.matchValue(node.sourceType, [...keys, 'sourceType'])) {
            return false;
        }
        if (typeof this.interpreter === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.interpreter === null) {
            // null matcher means we expect null value
            if (node.interpreter !== null) {
                return false;
            }
        }
        else if (!this.interpreter.matchValue(node.interpreter, [...keys, 'interpreter'])) {
            return false;
        }
        return true;
    }
}
exports.ProgramMatcher = ProgramMatcher;
function program(body, directives, sourceType, interpreter) {
    return new ProgramMatcher(body, directives, sourceType, interpreter);
}
exports.program = program;
class QualifiedTypeIdentifierMatcher extends Matcher_1.Matcher {
    constructor(id, qualification) {
        super();
        this.id = id;
        this.qualification = qualification;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isQualifiedTypeIdentifier(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.qualification === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.qualification.matchValue(node.qualification, [
            ...keys,
            'qualification',
        ])) {
            return false;
        }
        return true;
    }
}
exports.QualifiedTypeIdentifierMatcher = QualifiedTypeIdentifierMatcher;
function qualifiedTypeIdentifier(id, qualification) {
    return new QualifiedTypeIdentifierMatcher(id, qualification);
}
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
class RecordExpressionMatcher extends Matcher_1.Matcher {
    constructor(properties) {
        super();
        this.properties = properties;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isRecordExpression(node)) {
            return false;
        }
        if (typeof this.properties === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.properties)) {
            if (!(0, tupleOf_1.tupleOf)(...this.properties).matchValue(node.properties, [
                ...keys,
                'properties',
            ])) {
                return false;
            }
        }
        else if (!this.properties.matchValue(node.properties, [...keys, 'properties'])) {
            return false;
        }
        return true;
    }
}
exports.RecordExpressionMatcher = RecordExpressionMatcher;
function recordExpression(properties) {
    return new RecordExpressionMatcher(properties);
}
exports.recordExpression = recordExpression;
class RegExpLiteralMatcher extends Matcher_1.Matcher {
    constructor(pattern, flags) {
        super();
        this.pattern = pattern;
        this.flags = flags;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isRegExpLiteral(node)) {
            return false;
        }
        if (typeof this.pattern === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.pattern === 'string') {
            if (this.pattern !== node.pattern) {
                return false;
            }
        }
        else if (!this.pattern.matchValue(node.pattern, [...keys, 'pattern'])) {
            return false;
        }
        if (typeof this.flags === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.flags === 'string') {
            if (this.flags !== node.flags) {
                return false;
            }
        }
        else if (!this.flags.matchValue(node.flags, [...keys, 'flags'])) {
            return false;
        }
        return true;
    }
}
exports.RegExpLiteralMatcher = RegExpLiteralMatcher;
function regExpLiteral(pattern, flags) {
    return new RegExpLiteralMatcher(pattern, flags);
}
exports.regExpLiteral = regExpLiteral;
class RestElementMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isRestElement(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.RestElementMatcher = RestElementMatcher;
function restElement(argument) {
    return new RestElementMatcher(argument);
}
exports.restElement = restElement;
class ReturnStatementMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isReturnStatement(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.argument === null) {
            // null matcher means we expect null value
            if (node.argument !== null) {
                return false;
            }
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.ReturnStatementMatcher = ReturnStatementMatcher;
function returnStatement(argument) {
    return new ReturnStatementMatcher(argument);
}
exports.returnStatement = returnStatement;
class SequenceExpressionMatcher extends Matcher_1.Matcher {
    constructor(expressions) {
        super();
        this.expressions = expressions;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isSequenceExpression(node)) {
            return false;
        }
        if (typeof this.expressions === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.expressions)) {
            if (!(0, tupleOf_1.tupleOf)(...this.expressions).matchValue(node.expressions, [
                ...keys,
                'expressions',
            ])) {
                return false;
            }
        }
        else if (!this.expressions.matchValue(node.expressions, [...keys, 'expressions'])) {
            return false;
        }
        return true;
    }
}
exports.SequenceExpressionMatcher = SequenceExpressionMatcher;
function sequenceExpression(expressions) {
    return new SequenceExpressionMatcher(expressions);
}
exports.sequenceExpression = sequenceExpression;
class SpreadElementMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isSpreadElement(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.SpreadElementMatcher = SpreadElementMatcher;
function spreadElement(argument) {
    return new SpreadElementMatcher(argument);
}
exports.spreadElement = spreadElement;
class StaticBlockMatcher extends Matcher_1.Matcher {
    constructor(body) {
        super();
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isStaticBlock(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.body)) {
            if (!(0, tupleOf_1.tupleOf)(...this.body).matchValue(node.body, [...keys, 'body'])) {
                return false;
            }
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.StaticBlockMatcher = StaticBlockMatcher;
function staticBlock(body) {
    return new StaticBlockMatcher(body);
}
exports.staticBlock = staticBlock;
class StringLiteralMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isStringLiteral(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.StringLiteralMatcher = StringLiteralMatcher;
function stringLiteral(value) {
    return new StringLiteralMatcher(value);
}
exports.stringLiteral = stringLiteral;
class StringLiteralTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(value) {
        super();
        this.value = value;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isStringLiteralTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.value === 'string') {
            if (this.value !== node.value) {
                return false;
            }
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        return true;
    }
}
exports.StringLiteralTypeAnnotationMatcher = StringLiteralTypeAnnotationMatcher;
function stringLiteralTypeAnnotation(value) {
    return new StringLiteralTypeAnnotationMatcher(value);
}
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
class StringTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isStringTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.StringTypeAnnotationMatcher = StringTypeAnnotationMatcher;
function stringTypeAnnotation() {
    return new StringTypeAnnotationMatcher();
}
exports.stringTypeAnnotation = stringTypeAnnotation;
class SuperMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isSuper(node)) {
            return false;
        }
        return true;
    }
}
exports.SuperMatcher = SuperMatcher;
function Super() {
    return new SuperMatcher();
}
exports.Super = Super;
exports.super = Super;
class SwitchCaseMatcher extends Matcher_1.Matcher {
    constructor(test, consequent) {
        super();
        this.test = test;
        this.consequent = consequent;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isSwitchCase(node)) {
            return false;
        }
        if (typeof this.test === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.test === null) {
            // null matcher means we expect null value
            if (node.test !== null) {
                return false;
            }
        }
        else if (!this.test.matchValue(node.test, [...keys, 'test'])) {
            return false;
        }
        if (typeof this.consequent === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.consequent)) {
            if (!(0, tupleOf_1.tupleOf)(...this.consequent).matchValue(node.consequent, [
                ...keys,
                'consequent',
            ])) {
                return false;
            }
        }
        else if (!this.consequent.matchValue(node.consequent, [...keys, 'consequent'])) {
            return false;
        }
        return true;
    }
}
exports.SwitchCaseMatcher = SwitchCaseMatcher;
function switchCase(test, consequent) {
    return new SwitchCaseMatcher(test, consequent);
}
exports.switchCase = switchCase;
class SwitchStatementMatcher extends Matcher_1.Matcher {
    constructor(discriminant, cases) {
        super();
        this.discriminant = discriminant;
        this.cases = cases;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isSwitchStatement(node)) {
            return false;
        }
        if (typeof this.discriminant === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.discriminant.matchValue(node.discriminant, [
            ...keys,
            'discriminant',
        ])) {
            return false;
        }
        if (typeof this.cases === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.cases)) {
            if (!(0, tupleOf_1.tupleOf)(...this.cases).matchValue(node.cases, [
                ...keys,
                'cases',
            ])) {
                return false;
            }
        }
        else if (!this.cases.matchValue(node.cases, [...keys, 'cases'])) {
            return false;
        }
        return true;
    }
}
exports.SwitchStatementMatcher = SwitchStatementMatcher;
function switchStatement(discriminant, cases) {
    return new SwitchStatementMatcher(discriminant, cases);
}
exports.switchStatement = switchStatement;
class SymbolTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isSymbolTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.SymbolTypeAnnotationMatcher = SymbolTypeAnnotationMatcher;
function symbolTypeAnnotation() {
    return new SymbolTypeAnnotationMatcher();
}
exports.symbolTypeAnnotation = symbolTypeAnnotation;
class TSAnyKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSAnyKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSAnyKeywordMatcher = TSAnyKeywordMatcher;
function tsAnyKeyword() {
    return new TSAnyKeywordMatcher();
}
exports.tsAnyKeyword = tsAnyKeyword;
class TSArrayTypeMatcher extends Matcher_1.Matcher {
    constructor(elementType) {
        super();
        this.elementType = elementType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSArrayType(node)) {
            return false;
        }
        if (typeof this.elementType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.elementType.matchValue(node.elementType, [...keys, 'elementType'])) {
            return false;
        }
        return true;
    }
}
exports.TSArrayTypeMatcher = TSArrayTypeMatcher;
function tsArrayType(elementType) {
    return new TSArrayTypeMatcher(elementType);
}
exports.tsArrayType = tsArrayType;
class TSAsExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression, typeAnnotation) {
        super();
        this.expression = expression;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSAsExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSAsExpressionMatcher = TSAsExpressionMatcher;
function tsAsExpression(expression, typeAnnotation) {
    return new TSAsExpressionMatcher(expression, typeAnnotation);
}
exports.tsAsExpression = tsAsExpression;
class TSBigIntKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSBigIntKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSBigIntKeywordMatcher = TSBigIntKeywordMatcher;
function tsBigIntKeyword() {
    return new TSBigIntKeywordMatcher();
}
exports.tsBigIntKeyword = tsBigIntKeyword;
class TSBooleanKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSBooleanKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSBooleanKeywordMatcher = TSBooleanKeywordMatcher;
function tsBooleanKeyword() {
    return new TSBooleanKeywordMatcher();
}
exports.tsBooleanKeyword = tsBooleanKeyword;
class TSCallSignatureDeclarationMatcher extends Matcher_1.Matcher {
    constructor(typeParameters, parameters, typeAnnotation) {
        super();
        this.typeParameters = typeParameters;
        this.parameters = parameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSCallSignatureDeclaration(node)) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.parameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.parameters)) {
            if (!(0, tupleOf_1.tupleOf)(...this.parameters).matchValue(node.parameters, [
                ...keys,
                'parameters',
            ])) {
                return false;
            }
        }
        else if (!this.parameters.matchValue(node.parameters, [...keys, 'parameters'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSCallSignatureDeclarationMatcher = TSCallSignatureDeclarationMatcher;
function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return new TSCallSignatureDeclarationMatcher(typeParameters, parameters, typeAnnotation);
}
exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
class TSConditionalTypeMatcher extends Matcher_1.Matcher {
    constructor(checkType, extendsType, trueType, falseType) {
        super();
        this.checkType = checkType;
        this.extendsType = extendsType;
        this.trueType = trueType;
        this.falseType = falseType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSConditionalType(node)) {
            return false;
        }
        if (typeof this.checkType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.checkType.matchValue(node.checkType, [...keys, 'checkType'])) {
            return false;
        }
        if (typeof this.extendsType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.extendsType.matchValue(node.extendsType, [...keys, 'extendsType'])) {
            return false;
        }
        if (typeof this.trueType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.trueType.matchValue(node.trueType, [...keys, 'trueType'])) {
            return false;
        }
        if (typeof this.falseType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.falseType.matchValue(node.falseType, [...keys, 'falseType'])) {
            return false;
        }
        return true;
    }
}
exports.TSConditionalTypeMatcher = TSConditionalTypeMatcher;
function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return new TSConditionalTypeMatcher(checkType, extendsType, trueType, falseType);
}
exports.tsConditionalType = tsConditionalType;
class TSConstructSignatureDeclarationMatcher extends Matcher_1.Matcher {
    constructor(typeParameters, parameters, typeAnnotation) {
        super();
        this.typeParameters = typeParameters;
        this.parameters = parameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSConstructSignatureDeclaration(node)) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.parameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.parameters)) {
            if (!(0, tupleOf_1.tupleOf)(...this.parameters).matchValue(node.parameters, [
                ...keys,
                'parameters',
            ])) {
                return false;
            }
        }
        else if (!this.parameters.matchValue(node.parameters, [...keys, 'parameters'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSConstructSignatureDeclarationMatcher = TSConstructSignatureDeclarationMatcher;
function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return new TSConstructSignatureDeclarationMatcher(typeParameters, parameters, typeAnnotation);
}
exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
class TSConstructorTypeMatcher extends Matcher_1.Matcher {
    constructor(typeParameters, parameters, typeAnnotation) {
        super();
        this.typeParameters = typeParameters;
        this.parameters = parameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSConstructorType(node)) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.parameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.parameters)) {
            if (!(0, tupleOf_1.tupleOf)(...this.parameters).matchValue(node.parameters, [
                ...keys,
                'parameters',
            ])) {
                return false;
            }
        }
        else if (!this.parameters.matchValue(node.parameters, [...keys, 'parameters'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSConstructorTypeMatcher = TSConstructorTypeMatcher;
function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return new TSConstructorTypeMatcher(typeParameters, parameters, typeAnnotation);
}
exports.tsConstructorType = tsConstructorType;
class TSDeclareFunctionMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, params, returnType) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this.params = params;
        this.returnType = returnType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSDeclareFunction(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.id === null) {
            // null matcher means we expect null value
            if (node.id !== null) {
                return false;
            }
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.returnType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.returnType === null) {
            // null matcher means we expect null value
            if (node.returnType !== null) {
                return false;
            }
        }
        else if (!this.returnType.matchValue(node.returnType, [...keys, 'returnType'])) {
            return false;
        }
        return true;
    }
}
exports.TSDeclareFunctionMatcher = TSDeclareFunctionMatcher;
function tsDeclareFunction(id, typeParameters, params, returnType) {
    return new TSDeclareFunctionMatcher(id, typeParameters, params, returnType);
}
exports.tsDeclareFunction = tsDeclareFunction;
class TSDeclareMethodMatcher extends Matcher_1.Matcher {
    constructor(decorators, key, typeParameters, params, returnType) {
        super();
        this.decorators = decorators;
        this.key = key;
        this.typeParameters = typeParameters;
        this.params = params;
        this.returnType = returnType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSDeclareMethod(node)) {
            return false;
        }
        if (typeof this.decorators === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.decorators === null) {
            // null matcher means we expect null value
            if (node.decorators !== null) {
                return false;
            }
        }
        else if (Array.isArray(this.decorators)) {
            if (!(0, tupleOf_1.tupleOf)(...this.decorators).matchValue(node.decorators, [
                ...keys,
                'decorators',
            ])) {
                return false;
            }
        }
        else if (!this.decorators.matchValue(node.decorators, [...keys, 'decorators'])) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        if (typeof this.returnType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.returnType === null) {
            // null matcher means we expect null value
            if (node.returnType !== null) {
                return false;
            }
        }
        else if (!this.returnType.matchValue(node.returnType, [...keys, 'returnType'])) {
            return false;
        }
        return true;
    }
}
exports.TSDeclareMethodMatcher = TSDeclareMethodMatcher;
function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return new TSDeclareMethodMatcher(decorators, key, typeParameters, params, returnType);
}
exports.tsDeclareMethod = tsDeclareMethod;
class TSEnumDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, members) {
        super();
        this.id = id;
        this.members = members;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSEnumDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.members === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.members)) {
            if (!(0, tupleOf_1.tupleOf)(...this.members).matchValue(node.members, [
                ...keys,
                'members',
            ])) {
                return false;
            }
        }
        else if (!this.members.matchValue(node.members, [...keys, 'members'])) {
            return false;
        }
        return true;
    }
}
exports.TSEnumDeclarationMatcher = TSEnumDeclarationMatcher;
function tsEnumDeclaration(id, members) {
    return new TSEnumDeclarationMatcher(id, members);
}
exports.tsEnumDeclaration = tsEnumDeclaration;
class TSEnumMemberMatcher extends Matcher_1.Matcher {
    constructor(id, initializer) {
        super();
        this.id = id;
        this.initializer = initializer;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSEnumMember(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.initializer === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.initializer === null) {
            // null matcher means we expect null value
            if (node.initializer !== null) {
                return false;
            }
        }
        else if (!this.initializer.matchValue(node.initializer, [...keys, 'initializer'])) {
            return false;
        }
        return true;
    }
}
exports.TSEnumMemberMatcher = TSEnumMemberMatcher;
function tsEnumMember(id, initializer) {
    return new TSEnumMemberMatcher(id, initializer);
}
exports.tsEnumMember = tsEnumMember;
class TSExportAssignmentMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSExportAssignment(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.TSExportAssignmentMatcher = TSExportAssignmentMatcher;
function tsExportAssignment(expression) {
    return new TSExportAssignmentMatcher(expression);
}
exports.tsExportAssignment = tsExportAssignment;
class TSExpressionWithTypeArgumentsMatcher extends Matcher_1.Matcher {
    constructor(expression, typeParameters) {
        super();
        this.expression = expression;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSExpressionWithTypeArguments(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSExpressionWithTypeArgumentsMatcher = TSExpressionWithTypeArgumentsMatcher;
function tsExpressionWithTypeArguments(expression, typeParameters) {
    return new TSExpressionWithTypeArgumentsMatcher(expression, typeParameters);
}
exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
class TSExternalModuleReferenceMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSExternalModuleReference(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.TSExternalModuleReferenceMatcher = TSExternalModuleReferenceMatcher;
function tsExternalModuleReference(expression) {
    return new TSExternalModuleReferenceMatcher(expression);
}
exports.tsExternalModuleReference = tsExternalModuleReference;
class TSFunctionTypeMatcher extends Matcher_1.Matcher {
    constructor(typeParameters, parameters, typeAnnotation) {
        super();
        this.typeParameters = typeParameters;
        this.parameters = parameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSFunctionType(node)) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.parameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.parameters)) {
            if (!(0, tupleOf_1.tupleOf)(...this.parameters).matchValue(node.parameters, [
                ...keys,
                'parameters',
            ])) {
                return false;
            }
        }
        else if (!this.parameters.matchValue(node.parameters, [...keys, 'parameters'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSFunctionTypeMatcher = TSFunctionTypeMatcher;
function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return new TSFunctionTypeMatcher(typeParameters, parameters, typeAnnotation);
}
exports.tsFunctionType = tsFunctionType;
class TSImportEqualsDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, moduleReference) {
        super();
        this.id = id;
        this.moduleReference = moduleReference;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSImportEqualsDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.moduleReference === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.moduleReference.matchValue(node.moduleReference, [
            ...keys,
            'moduleReference',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSImportEqualsDeclarationMatcher = TSImportEqualsDeclarationMatcher;
function tsImportEqualsDeclaration(id, moduleReference) {
    return new TSImportEqualsDeclarationMatcher(id, moduleReference);
}
exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
class TSImportTypeMatcher extends Matcher_1.Matcher {
    constructor(argument, qualifier, typeParameters) {
        super();
        this.argument = argument;
        this.qualifier = qualifier;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSImportType(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        if (typeof this.qualifier === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.qualifier === null) {
            // null matcher means we expect null value
            if (node.qualifier !== null) {
                return false;
            }
        }
        else if (!this.qualifier.matchValue(node.qualifier, [...keys, 'qualifier'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSImportTypeMatcher = TSImportTypeMatcher;
function tsImportType(argument, qualifier, typeParameters) {
    return new TSImportTypeMatcher(argument, qualifier, typeParameters);
}
exports.tsImportType = tsImportType;
class TSIndexSignatureMatcher extends Matcher_1.Matcher {
    constructor(parameters, typeAnnotation) {
        super();
        this.parameters = parameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSIndexSignature(node)) {
            return false;
        }
        if (typeof this.parameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.parameters)) {
            if (!(0, tupleOf_1.tupleOf)(...this.parameters).matchValue(node.parameters, [
                ...keys,
                'parameters',
            ])) {
                return false;
            }
        }
        else if (!this.parameters.matchValue(node.parameters, [...keys, 'parameters'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSIndexSignatureMatcher = TSIndexSignatureMatcher;
function tsIndexSignature(parameters, typeAnnotation) {
    return new TSIndexSignatureMatcher(parameters, typeAnnotation);
}
exports.tsIndexSignature = tsIndexSignature;
class TSIndexedAccessTypeMatcher extends Matcher_1.Matcher {
    constructor(objectType, indexType) {
        super();
        this.objectType = objectType;
        this.indexType = indexType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSIndexedAccessType(node)) {
            return false;
        }
        if (typeof this.objectType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.objectType.matchValue(node.objectType, [...keys, 'objectType'])) {
            return false;
        }
        if (typeof this.indexType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.indexType.matchValue(node.indexType, [...keys, 'indexType'])) {
            return false;
        }
        return true;
    }
}
exports.TSIndexedAccessTypeMatcher = TSIndexedAccessTypeMatcher;
function tsIndexedAccessType(objectType, indexType) {
    return new TSIndexedAccessTypeMatcher(objectType, indexType);
}
exports.tsIndexedAccessType = tsIndexedAccessType;
class TSInferTypeMatcher extends Matcher_1.Matcher {
    constructor(typeParameter) {
        super();
        this.typeParameter = typeParameter;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSInferType(node)) {
            return false;
        }
        if (typeof this.typeParameter === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeParameter.matchValue(node.typeParameter, [
            ...keys,
            'typeParameter',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSInferTypeMatcher = TSInferTypeMatcher;
function tsInferType(typeParameter) {
    return new TSInferTypeMatcher(typeParameter);
}
exports.tsInferType = tsInferType;
class TSInstantiationExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression, typeParameters) {
        super();
        this.expression = expression;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSInstantiationExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSInstantiationExpressionMatcher = TSInstantiationExpressionMatcher;
function tsInstantiationExpression(expression, typeParameters) {
    return new TSInstantiationExpressionMatcher(expression, typeParameters);
}
exports.tsInstantiationExpression = tsInstantiationExpression;
class TSInterfaceBodyMatcher extends Matcher_1.Matcher {
    constructor(body) {
        super();
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSInterfaceBody(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.body)) {
            if (!(0, tupleOf_1.tupleOf)(...this.body).matchValue(node.body, [...keys, 'body'])) {
                return false;
            }
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.TSInterfaceBodyMatcher = TSInterfaceBodyMatcher;
function tsInterfaceBody(body) {
    return new TSInterfaceBodyMatcher(body);
}
exports.tsInterfaceBody = tsInterfaceBody;
class TSInterfaceDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, _extends, body) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this._extends = _extends;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSInterfaceDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this._extends === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._extends === null) {
            // null matcher means we expect null value
            if (node.extends !== null) {
                return false;
            }
        }
        else if (Array.isArray(this._extends)) {
            if (!(0, tupleOf_1.tupleOf)(...this._extends).matchValue(node.extends, [
                ...keys,
                'extends',
            ])) {
                return false;
            }
        }
        else if (!this._extends.matchValue(node.extends, [...keys, 'extends'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.TSInterfaceDeclarationMatcher = TSInterfaceDeclarationMatcher;
function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return new TSInterfaceDeclarationMatcher(id, typeParameters, _extends, body);
}
exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
class TSIntersectionTypeMatcher extends Matcher_1.Matcher {
    constructor(types) {
        super();
        this.types = types;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSIntersectionType(node)) {
            return false;
        }
        if (typeof this.types === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.types)) {
            if (!(0, tupleOf_1.tupleOf)(...this.types).matchValue(node.types, [
                ...keys,
                'types',
            ])) {
                return false;
            }
        }
        else if (!this.types.matchValue(node.types, [...keys, 'types'])) {
            return false;
        }
        return true;
    }
}
exports.TSIntersectionTypeMatcher = TSIntersectionTypeMatcher;
function tsIntersectionType(types) {
    return new TSIntersectionTypeMatcher(types);
}
exports.tsIntersectionType = tsIntersectionType;
class TSIntrinsicKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSIntrinsicKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSIntrinsicKeywordMatcher = TSIntrinsicKeywordMatcher;
function tsIntrinsicKeyword() {
    return new TSIntrinsicKeywordMatcher();
}
exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
class TSLiteralTypeMatcher extends Matcher_1.Matcher {
    constructor(literal) {
        super();
        this.literal = literal;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSLiteralType(node)) {
            return false;
        }
        if (typeof this.literal === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.literal.matchValue(node.literal, [...keys, 'literal'])) {
            return false;
        }
        return true;
    }
}
exports.TSLiteralTypeMatcher = TSLiteralTypeMatcher;
function tsLiteralType(literal) {
    return new TSLiteralTypeMatcher(literal);
}
exports.tsLiteralType = tsLiteralType;
class TSMappedTypeMatcher extends Matcher_1.Matcher {
    constructor(typeParameter, typeAnnotation, nameType) {
        super();
        this.typeParameter = typeParameter;
        this.typeAnnotation = typeAnnotation;
        this.nameType = nameType;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSMappedType(node)) {
            return false;
        }
        if (typeof this.typeParameter === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeParameter.matchValue(node.typeParameter, [
            ...keys,
            'typeParameter',
        ])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        if (typeof this.nameType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.nameType === null) {
            // null matcher means we expect null value
            if (node.nameType !== null) {
                return false;
            }
        }
        else if (!this.nameType.matchValue(node.nameType, [...keys, 'nameType'])) {
            return false;
        }
        return true;
    }
}
exports.TSMappedTypeMatcher = TSMappedTypeMatcher;
function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return new TSMappedTypeMatcher(typeParameter, typeAnnotation, nameType);
}
exports.tsMappedType = tsMappedType;
class TSMethodSignatureMatcher extends Matcher_1.Matcher {
    constructor(key, typeParameters, parameters, typeAnnotation) {
        super();
        this.key = key;
        this.typeParameters = typeParameters;
        this.parameters = parameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSMethodSignature(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.parameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.parameters)) {
            if (!(0, tupleOf_1.tupleOf)(...this.parameters).matchValue(node.parameters, [
                ...keys,
                'parameters',
            ])) {
                return false;
            }
        }
        else if (!this.parameters.matchValue(node.parameters, [...keys, 'parameters'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSMethodSignatureMatcher = TSMethodSignatureMatcher;
function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return new TSMethodSignatureMatcher(key, typeParameters, parameters, typeAnnotation);
}
exports.tsMethodSignature = tsMethodSignature;
class TSModuleBlockMatcher extends Matcher_1.Matcher {
    constructor(body) {
        super();
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSModuleBlock(node)) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.body)) {
            if (!(0, tupleOf_1.tupleOf)(...this.body).matchValue(node.body, [...keys, 'body'])) {
                return false;
            }
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.TSModuleBlockMatcher = TSModuleBlockMatcher;
function tsModuleBlock(body) {
    return new TSModuleBlockMatcher(body);
}
exports.tsModuleBlock = tsModuleBlock;
class TSModuleDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, body) {
        super();
        this.id = id;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSModuleDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.TSModuleDeclarationMatcher = TSModuleDeclarationMatcher;
function tsModuleDeclaration(id, body) {
    return new TSModuleDeclarationMatcher(id, body);
}
exports.tsModuleDeclaration = tsModuleDeclaration;
class TSNamedTupleMemberMatcher extends Matcher_1.Matcher {
    constructor(label, elementType, optional) {
        super();
        this.label = label;
        this.elementType = elementType;
        this.optional = optional;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSNamedTupleMember(node)) {
            return false;
        }
        if (typeof this.label === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.label.matchValue(node.label, [...keys, 'label'])) {
            return false;
        }
        if (typeof this.elementType === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.elementType.matchValue(node.elementType, [...keys, 'elementType'])) {
            return false;
        }
        if (typeof this.optional === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.optional === 'boolean') {
            if (this.optional !== node.optional) {
                return false;
            }
        }
        else if (!this.optional.matchValue(node.optional, [...keys, 'optional'])) {
            return false;
        }
        return true;
    }
}
exports.TSNamedTupleMemberMatcher = TSNamedTupleMemberMatcher;
function tsNamedTupleMember(label, elementType, optional) {
    return new TSNamedTupleMemberMatcher(label, elementType, optional);
}
exports.tsNamedTupleMember = tsNamedTupleMember;
class TSNamespaceExportDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSNamespaceExportDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        return true;
    }
}
exports.TSNamespaceExportDeclarationMatcher = TSNamespaceExportDeclarationMatcher;
function tsNamespaceExportDeclaration(id) {
    return new TSNamespaceExportDeclarationMatcher(id);
}
exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
class TSNeverKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSNeverKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSNeverKeywordMatcher = TSNeverKeywordMatcher;
function tsNeverKeyword() {
    return new TSNeverKeywordMatcher();
}
exports.tsNeverKeyword = tsNeverKeyword;
class TSNonNullExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSNonNullExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.TSNonNullExpressionMatcher = TSNonNullExpressionMatcher;
function tsNonNullExpression(expression) {
    return new TSNonNullExpressionMatcher(expression);
}
exports.tsNonNullExpression = tsNonNullExpression;
class TSNullKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSNullKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSNullKeywordMatcher = TSNullKeywordMatcher;
function tsNullKeyword() {
    return new TSNullKeywordMatcher();
}
exports.tsNullKeyword = tsNullKeyword;
class TSNumberKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSNumberKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSNumberKeywordMatcher = TSNumberKeywordMatcher;
function tsNumberKeyword() {
    return new TSNumberKeywordMatcher();
}
exports.tsNumberKeyword = tsNumberKeyword;
class TSObjectKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSObjectKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSObjectKeywordMatcher = TSObjectKeywordMatcher;
function tsObjectKeyword() {
    return new TSObjectKeywordMatcher();
}
exports.tsObjectKeyword = tsObjectKeyword;
class TSOptionalTypeMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSOptionalType(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSOptionalTypeMatcher = TSOptionalTypeMatcher;
function tsOptionalType(typeAnnotation) {
    return new TSOptionalTypeMatcher(typeAnnotation);
}
exports.tsOptionalType = tsOptionalType;
class TSParameterPropertyMatcher extends Matcher_1.Matcher {
    constructor(parameter) {
        super();
        this.parameter = parameter;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSParameterProperty(node)) {
            return false;
        }
        if (typeof this.parameter === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.parameter.matchValue(node.parameter, [...keys, 'parameter'])) {
            return false;
        }
        return true;
    }
}
exports.TSParameterPropertyMatcher = TSParameterPropertyMatcher;
function tsParameterProperty(parameter) {
    return new TSParameterPropertyMatcher(parameter);
}
exports.tsParameterProperty = tsParameterProperty;
class TSParenthesizedTypeMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSParenthesizedType(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSParenthesizedTypeMatcher = TSParenthesizedTypeMatcher;
function tsParenthesizedType(typeAnnotation) {
    return new TSParenthesizedTypeMatcher(typeAnnotation);
}
exports.tsParenthesizedType = tsParenthesizedType;
class TSPropertySignatureMatcher extends Matcher_1.Matcher {
    constructor(key, typeAnnotation, initializer) {
        super();
        this.key = key;
        this.typeAnnotation = typeAnnotation;
        this.initializer = initializer;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSPropertySignature(node)) {
            return false;
        }
        if (typeof this.key === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.key.matchValue(node.key, [...keys, 'key'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        if (typeof this.initializer === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.initializer === null) {
            // null matcher means we expect null value
            if (node.initializer !== null) {
                return false;
            }
        }
        else if (!this.initializer.matchValue(node.initializer, [...keys, 'initializer'])) {
            return false;
        }
        return true;
    }
}
exports.TSPropertySignatureMatcher = TSPropertySignatureMatcher;
function tsPropertySignature(key, typeAnnotation, initializer) {
    return new TSPropertySignatureMatcher(key, typeAnnotation, initializer);
}
exports.tsPropertySignature = tsPropertySignature;
class TSQualifiedNameMatcher extends Matcher_1.Matcher {
    constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSQualifiedName(node)) {
            return false;
        }
        if (typeof this.left === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.left.matchValue(node.left, [...keys, 'left'])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.TSQualifiedNameMatcher = TSQualifiedNameMatcher;
function tsQualifiedName(left, right) {
    return new TSQualifiedNameMatcher(left, right);
}
exports.tsQualifiedName = tsQualifiedName;
class TSRestTypeMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSRestType(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSRestTypeMatcher = TSRestTypeMatcher;
function tsRestType(typeAnnotation) {
    return new TSRestTypeMatcher(typeAnnotation);
}
exports.tsRestType = tsRestType;
class TSSatisfiesExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression, typeAnnotation) {
        super();
        this.expression = expression;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSSatisfiesExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSSatisfiesExpressionMatcher = TSSatisfiesExpressionMatcher;
function tsSatisfiesExpression(expression, typeAnnotation) {
    return new TSSatisfiesExpressionMatcher(expression, typeAnnotation);
}
exports.tsSatisfiesExpression = tsSatisfiesExpression;
class TSStringKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSStringKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSStringKeywordMatcher = TSStringKeywordMatcher;
function tsStringKeyword() {
    return new TSStringKeywordMatcher();
}
exports.tsStringKeyword = tsStringKeyword;
class TSSymbolKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSSymbolKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSSymbolKeywordMatcher = TSSymbolKeywordMatcher;
function tsSymbolKeyword() {
    return new TSSymbolKeywordMatcher();
}
exports.tsSymbolKeyword = tsSymbolKeyword;
class TSThisTypeMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSThisType(node)) {
            return false;
        }
        return true;
    }
}
exports.TSThisTypeMatcher = TSThisTypeMatcher;
function tsThisType() {
    return new TSThisTypeMatcher();
}
exports.tsThisType = tsThisType;
class TSTupleTypeMatcher extends Matcher_1.Matcher {
    constructor(elementTypes) {
        super();
        this.elementTypes = elementTypes;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTupleType(node)) {
            return false;
        }
        if (typeof this.elementTypes === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.elementTypes)) {
            if (!(0, tupleOf_1.tupleOf)(...this.elementTypes).matchValue(node.elementTypes, [
                ...keys,
                'elementTypes',
            ])) {
                return false;
            }
        }
        else if (!this.elementTypes.matchValue(node.elementTypes, [
            ...keys,
            'elementTypes',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSTupleTypeMatcher = TSTupleTypeMatcher;
function tsTupleType(elementTypes) {
    return new TSTupleTypeMatcher(elementTypes);
}
exports.tsTupleType = tsTupleType;
class TSTypeAliasDeclarationMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, typeAnnotation) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeAliasDeclaration(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeAliasDeclarationMatcher = TSTypeAliasDeclarationMatcher;
function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return new TSTypeAliasDeclarationMatcher(id, typeParameters, typeAnnotation);
}
exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
class TSTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeAnnotationMatcher = TSTypeAnnotationMatcher;
function tsTypeAnnotation(typeAnnotation) {
    return new TSTypeAnnotationMatcher(typeAnnotation);
}
exports.tsTypeAnnotation = tsTypeAnnotation;
class TSTypeAssertionMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation, expression) {
        super();
        this.typeAnnotation = typeAnnotation;
        this.expression = expression;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeAssertion(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeAssertionMatcher = TSTypeAssertionMatcher;
function tsTypeAssertion(typeAnnotation, expression) {
    return new TSTypeAssertionMatcher(typeAnnotation, expression);
}
exports.tsTypeAssertion = tsTypeAssertion;
class TSTypeLiteralMatcher extends Matcher_1.Matcher {
    constructor(members) {
        super();
        this.members = members;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeLiteral(node)) {
            return false;
        }
        if (typeof this.members === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.members)) {
            if (!(0, tupleOf_1.tupleOf)(...this.members).matchValue(node.members, [
                ...keys,
                'members',
            ])) {
                return false;
            }
        }
        else if (!this.members.matchValue(node.members, [...keys, 'members'])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeLiteralMatcher = TSTypeLiteralMatcher;
function tsTypeLiteral(members) {
    return new TSTypeLiteralMatcher(members);
}
exports.tsTypeLiteral = tsTypeLiteral;
class TSTypeOperatorMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeOperator(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeOperatorMatcher = TSTypeOperatorMatcher;
function tsTypeOperator(typeAnnotation) {
    return new TSTypeOperatorMatcher(typeAnnotation);
}
exports.tsTypeOperator = tsTypeOperator;
class TSTypeParameterMatcher extends Matcher_1.Matcher {
    constructor(constraint, _default, name) {
        super();
        this.constraint = constraint;
        this._default = _default;
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeParameter(node)) {
            return false;
        }
        if (typeof this.constraint === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.constraint === null) {
            // null matcher means we expect null value
            if (node.constraint !== null) {
                return false;
            }
        }
        else if (!this.constraint.matchValue(node.constraint, [...keys, 'constraint'])) {
            return false;
        }
        if (typeof this._default === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._default === null) {
            // null matcher means we expect null value
            if (node.default !== null) {
                return false;
            }
        }
        else if (!this._default.matchValue(node.default, [...keys, 'default'])) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.name === 'string') {
            if (this.name !== node.name) {
                return false;
            }
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeParameterMatcher = TSTypeParameterMatcher;
function tsTypeParameter(constraint, _default, name) {
    return new TSTypeParameterMatcher(constraint, _default, name);
}
exports.tsTypeParameter = tsTypeParameter;
class TSTypeParameterDeclarationMatcher extends Matcher_1.Matcher {
    constructor(params) {
        super();
        this.params = params;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeParameterDeclaration(node)) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeParameterDeclarationMatcher = TSTypeParameterDeclarationMatcher;
function tsTypeParameterDeclaration(params) {
    return new TSTypeParameterDeclarationMatcher(params);
}
exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
class TSTypeParameterInstantiationMatcher extends Matcher_1.Matcher {
    constructor(params) {
        super();
        this.params = params;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeParameterInstantiation(node)) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeParameterInstantiationMatcher = TSTypeParameterInstantiationMatcher;
function tsTypeParameterInstantiation(params) {
    return new TSTypeParameterInstantiationMatcher(params);
}
exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
class TSTypePredicateMatcher extends Matcher_1.Matcher {
    constructor(parameterName, typeAnnotation, asserts) {
        super();
        this.parameterName = parameterName;
        this.typeAnnotation = typeAnnotation;
        this.asserts = asserts;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypePredicate(node)) {
            return false;
        }
        if (typeof this.parameterName === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.parameterName.matchValue(node.parameterName, [
            ...keys,
            'parameterName',
        ])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeAnnotation === null) {
            // null matcher means we expect null value
            if (node.typeAnnotation !== null) {
                return false;
            }
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        if (typeof this.asserts === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.asserts === 'boolean') {
            if (this.asserts !== node.asserts) {
                return false;
            }
        }
        else if (this.asserts === null) {
            // null matcher means we expect null value
            if (node.asserts !== null) {
                return false;
            }
        }
        else if (!this.asserts.matchValue(node.asserts, [...keys, 'asserts'])) {
            return false;
        }
        return true;
    }
}
exports.TSTypePredicateMatcher = TSTypePredicateMatcher;
function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return new TSTypePredicateMatcher(parameterName, typeAnnotation, asserts);
}
exports.tsTypePredicate = tsTypePredicate;
class TSTypeQueryMatcher extends Matcher_1.Matcher {
    constructor(exprName, typeParameters) {
        super();
        this.exprName = exprName;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeQuery(node)) {
            return false;
        }
        if (typeof this.exprName === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.exprName.matchValue(node.exprName, [...keys, 'exprName'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeQueryMatcher = TSTypeQueryMatcher;
function tsTypeQuery(exprName, typeParameters) {
    return new TSTypeQueryMatcher(exprName, typeParameters);
}
exports.tsTypeQuery = tsTypeQuery;
class TSTypeReferenceMatcher extends Matcher_1.Matcher {
    constructor(typeName, typeParameters) {
        super();
        this.typeName = typeName;
        this.typeParameters = typeParameters;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSTypeReference(node)) {
            return false;
        }
        if (typeof this.typeName === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeName.matchValue(node.typeName, [...keys, 'typeName'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TSTypeReferenceMatcher = TSTypeReferenceMatcher;
function tsTypeReference(typeName, typeParameters) {
    return new TSTypeReferenceMatcher(typeName, typeParameters);
}
exports.tsTypeReference = tsTypeReference;
class TSUndefinedKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSUndefinedKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSUndefinedKeywordMatcher = TSUndefinedKeywordMatcher;
function tsUndefinedKeyword() {
    return new TSUndefinedKeywordMatcher();
}
exports.tsUndefinedKeyword = tsUndefinedKeyword;
class TSUnionTypeMatcher extends Matcher_1.Matcher {
    constructor(types) {
        super();
        this.types = types;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSUnionType(node)) {
            return false;
        }
        if (typeof this.types === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.types)) {
            if (!(0, tupleOf_1.tupleOf)(...this.types).matchValue(node.types, [
                ...keys,
                'types',
            ])) {
                return false;
            }
        }
        else if (!this.types.matchValue(node.types, [...keys, 'types'])) {
            return false;
        }
        return true;
    }
}
exports.TSUnionTypeMatcher = TSUnionTypeMatcher;
function tsUnionType(types) {
    return new TSUnionTypeMatcher(types);
}
exports.tsUnionType = tsUnionType;
class TSUnknownKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSUnknownKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSUnknownKeywordMatcher = TSUnknownKeywordMatcher;
function tsUnknownKeyword() {
    return new TSUnknownKeywordMatcher();
}
exports.tsUnknownKeyword = tsUnknownKeyword;
class TSVoidKeywordMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTSVoidKeyword(node)) {
            return false;
        }
        return true;
    }
}
exports.TSVoidKeywordMatcher = TSVoidKeywordMatcher;
function tsVoidKeyword() {
    return new TSVoidKeywordMatcher();
}
exports.tsVoidKeyword = tsVoidKeyword;
class TaggedTemplateExpressionMatcher extends Matcher_1.Matcher {
    constructor(tag, quasi) {
        super();
        this.tag = tag;
        this.quasi = quasi;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTaggedTemplateExpression(node)) {
            return false;
        }
        if (typeof this.tag === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.tag.matchValue(node.tag, [...keys, 'tag'])) {
            return false;
        }
        if (typeof this.quasi === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.quasi.matchValue(node.quasi, [...keys, 'quasi'])) {
            return false;
        }
        return true;
    }
}
exports.TaggedTemplateExpressionMatcher = TaggedTemplateExpressionMatcher;
function taggedTemplateExpression(tag, quasi) {
    return new TaggedTemplateExpressionMatcher(tag, quasi);
}
exports.taggedTemplateExpression = taggedTemplateExpression;
class TemplateElementMatcher extends Matcher_1.Matcher {
    constructor(value, tail) {
        super();
        this.value = value;
        this.tail = tail;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTemplateElement(node)) {
            return false;
        }
        if (typeof this.value === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.value.matchValue(node.value, [...keys, 'value'])) {
            return false;
        }
        if (typeof this.tail === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.tail === 'boolean') {
            if (this.tail !== node.tail) {
                return false;
            }
        }
        else if (!this.tail.matchValue(node.tail, [...keys, 'tail'])) {
            return false;
        }
        return true;
    }
}
exports.TemplateElementMatcher = TemplateElementMatcher;
function templateElement(value, tail) {
    return new TemplateElementMatcher(value, tail);
}
exports.templateElement = templateElement;
class TemplateLiteralMatcher extends Matcher_1.Matcher {
    constructor(quasis, expressions) {
        super();
        this.quasis = quasis;
        this.expressions = expressions;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTemplateLiteral(node)) {
            return false;
        }
        if (typeof this.quasis === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.quasis)) {
            if (!(0, tupleOf_1.tupleOf)(...this.quasis).matchValue(node.quasis, [
                ...keys,
                'quasis',
            ])) {
                return false;
            }
        }
        else if (!this.quasis.matchValue(node.quasis, [...keys, 'quasis'])) {
            return false;
        }
        if (typeof this.expressions === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.expressions)) {
            if (!(0, tupleOf_1.tupleOf)(...this.expressions).matchValue(node.expressions, [
                ...keys,
                'expressions',
            ])) {
                return false;
            }
        }
        else if (!this.expressions.matchValue(node.expressions, [...keys, 'expressions'])) {
            return false;
        }
        return true;
    }
}
exports.TemplateLiteralMatcher = TemplateLiteralMatcher;
function templateLiteral(quasis, expressions) {
    return new TemplateLiteralMatcher(quasis, expressions);
}
exports.templateLiteral = templateLiteral;
class ThisExpressionMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isThisExpression(node)) {
            return false;
        }
        return true;
    }
}
exports.ThisExpressionMatcher = ThisExpressionMatcher;
function thisExpression() {
    return new ThisExpressionMatcher();
}
exports.thisExpression = thisExpression;
class ThisTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isThisTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.ThisTypeAnnotationMatcher = ThisTypeAnnotationMatcher;
function thisTypeAnnotation() {
    return new ThisTypeAnnotationMatcher();
}
exports.thisTypeAnnotation = thisTypeAnnotation;
class ThrowStatementMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isThrowStatement(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.ThrowStatementMatcher = ThrowStatementMatcher;
function throwStatement(argument) {
    return new ThrowStatementMatcher(argument);
}
exports.throwStatement = throwStatement;
class TopicReferenceMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTopicReference(node)) {
            return false;
        }
        return true;
    }
}
exports.TopicReferenceMatcher = TopicReferenceMatcher;
function topicReference() {
    return new TopicReferenceMatcher();
}
exports.topicReference = topicReference;
class TryStatementMatcher extends Matcher_1.Matcher {
    constructor(block, handler, finalizer) {
        super();
        this.block = block;
        this.handler = handler;
        this.finalizer = finalizer;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTryStatement(node)) {
            return false;
        }
        if (typeof this.block === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.block.matchValue(node.block, [...keys, 'block'])) {
            return false;
        }
        if (typeof this.handler === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.handler === null) {
            // null matcher means we expect null value
            if (node.handler !== null) {
                return false;
            }
        }
        else if (!this.handler.matchValue(node.handler, [...keys, 'handler'])) {
            return false;
        }
        if (typeof this.finalizer === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.finalizer === null) {
            // null matcher means we expect null value
            if (node.finalizer !== null) {
                return false;
            }
        }
        else if (!this.finalizer.matchValue(node.finalizer, [...keys, 'finalizer'])) {
            return false;
        }
        return true;
    }
}
exports.TryStatementMatcher = TryStatementMatcher;
function tryStatement(block, handler, finalizer) {
    return new TryStatementMatcher(block, handler, finalizer);
}
exports.tryStatement = tryStatement;
class TupleExpressionMatcher extends Matcher_1.Matcher {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTupleExpression(node)) {
            return false;
        }
        if (typeof this.elements === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.elements)) {
            if (!(0, tupleOf_1.tupleOf)(...this.elements).matchValue(node.elements, [
                ...keys,
                'elements',
            ])) {
                return false;
            }
        }
        else if (!this.elements.matchValue(node.elements, [...keys, 'elements'])) {
            return false;
        }
        return true;
    }
}
exports.TupleExpressionMatcher = TupleExpressionMatcher;
function tupleExpression(elements) {
    return new TupleExpressionMatcher(elements);
}
exports.tupleExpression = tupleExpression;
class TupleTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(types) {
        super();
        this.types = types;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTupleTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.types === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.types)) {
            if (!(0, tupleOf_1.tupleOf)(...this.types).matchValue(node.types, [
                ...keys,
                'types',
            ])) {
                return false;
            }
        }
        else if (!this.types.matchValue(node.types, [...keys, 'types'])) {
            return false;
        }
        return true;
    }
}
exports.TupleTypeAnnotationMatcher = TupleTypeAnnotationMatcher;
function tupleTypeAnnotation(types) {
    return new TupleTypeAnnotationMatcher(types);
}
exports.tupleTypeAnnotation = tupleTypeAnnotation;
class TypeAliasMatcher extends Matcher_1.Matcher {
    constructor(id, typeParameters, right) {
        super();
        this.id = id;
        this.typeParameters = typeParameters;
        this.right = right;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeAlias(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.typeParameters === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.typeParameters === null) {
            // null matcher means we expect null value
            if (node.typeParameters !== null) {
                return false;
            }
        }
        else if (!this.typeParameters.matchValue(node.typeParameters, [
            ...keys,
            'typeParameters',
        ])) {
            return false;
        }
        if (typeof this.right === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.right.matchValue(node.right, [...keys, 'right'])) {
            return false;
        }
        return true;
    }
}
exports.TypeAliasMatcher = TypeAliasMatcher;
function typeAlias(id, typeParameters, right) {
    return new TypeAliasMatcher(id, typeParameters, right);
}
exports.typeAlias = typeAlias;
class TypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(typeAnnotation) {
        super();
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TypeAnnotationMatcher = TypeAnnotationMatcher;
function typeAnnotation(typeAnnotation) {
    return new TypeAnnotationMatcher(typeAnnotation);
}
exports.typeAnnotation = typeAnnotation;
class TypeCastExpressionMatcher extends Matcher_1.Matcher {
    constructor(expression, typeAnnotation) {
        super();
        this.expression = expression;
        this.typeAnnotation = typeAnnotation;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeCastExpression(node)) {
            return false;
        }
        if (typeof this.expression === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.expression.matchValue(node.expression, [...keys, 'expression'])) {
            return false;
        }
        if (typeof this.typeAnnotation === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.typeAnnotation.matchValue(node.typeAnnotation, [
            ...keys,
            'typeAnnotation',
        ])) {
            return false;
        }
        return true;
    }
}
exports.TypeCastExpressionMatcher = TypeCastExpressionMatcher;
function typeCastExpression(expression, typeAnnotation) {
    return new TypeCastExpressionMatcher(expression, typeAnnotation);
}
exports.typeCastExpression = typeCastExpression;
class TypeParameterMatcher extends Matcher_1.Matcher {
    constructor(bound, _default, variance) {
        super();
        this.bound = bound;
        this._default = _default;
        this.variance = variance;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeParameter(node)) {
            return false;
        }
        if (typeof this.bound === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.bound === null) {
            // null matcher means we expect null value
            if (node.bound !== null) {
                return false;
            }
        }
        else if (!this.bound.matchValue(node.bound, [...keys, 'bound'])) {
            return false;
        }
        if (typeof this._default === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this._default === null) {
            // null matcher means we expect null value
            if (node.default !== null) {
                return false;
            }
        }
        else if (!this._default.matchValue(node.default, [...keys, 'default'])) {
            return false;
        }
        if (typeof this.variance === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.variance === null) {
            // null matcher means we expect null value
            if (node.variance !== null) {
                return false;
            }
        }
        else if (!this.variance.matchValue(node.variance, [...keys, 'variance'])) {
            return false;
        }
        return true;
    }
}
exports.TypeParameterMatcher = TypeParameterMatcher;
function typeParameter(bound, _default, variance) {
    return new TypeParameterMatcher(bound, _default, variance);
}
exports.typeParameter = typeParameter;
class TypeParameterDeclarationMatcher extends Matcher_1.Matcher {
    constructor(params) {
        super();
        this.params = params;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeParameterDeclaration(node)) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        return true;
    }
}
exports.TypeParameterDeclarationMatcher = TypeParameterDeclarationMatcher;
function typeParameterDeclaration(params) {
    return new TypeParameterDeclarationMatcher(params);
}
exports.typeParameterDeclaration = typeParameterDeclaration;
class TypeParameterInstantiationMatcher extends Matcher_1.Matcher {
    constructor(params) {
        super();
        this.params = params;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeParameterInstantiation(node)) {
            return false;
        }
        if (typeof this.params === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.params)) {
            if (!(0, tupleOf_1.tupleOf)(...this.params).matchValue(node.params, [
                ...keys,
                'params',
            ])) {
                return false;
            }
        }
        else if (!this.params.matchValue(node.params, [...keys, 'params'])) {
            return false;
        }
        return true;
    }
}
exports.TypeParameterInstantiationMatcher = TypeParameterInstantiationMatcher;
function typeParameterInstantiation(params) {
    return new TypeParameterInstantiationMatcher(params);
}
exports.typeParameterInstantiation = typeParameterInstantiation;
class TypeofTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(argument) {
        super();
        this.argument = argument;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isTypeofTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        return true;
    }
}
exports.TypeofTypeAnnotationMatcher = TypeofTypeAnnotationMatcher;
function typeofTypeAnnotation(argument) {
    return new TypeofTypeAnnotationMatcher(argument);
}
exports.typeofTypeAnnotation = typeofTypeAnnotation;
class UnaryExpressionMatcher extends Matcher_1.Matcher {
    constructor(operator, argument, prefix) {
        super();
        this.operator = operator;
        this.argument = argument;
        this.prefix = prefix;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isUnaryExpression(node)) {
            return false;
        }
        if (typeof this.operator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.operator === 'string') {
            if (this.operator !== node.operator) {
                return false;
            }
        }
        else if (!this.operator.matchValue(node.operator, [...keys, 'operator'])) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        if (typeof this.prefix === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.prefix === 'boolean') {
            if (this.prefix !== node.prefix) {
                return false;
            }
        }
        else if (!this.prefix.matchValue(node.prefix, [...keys, 'prefix'])) {
            return false;
        }
        return true;
    }
}
exports.UnaryExpressionMatcher = UnaryExpressionMatcher;
function unaryExpression(operator, argument, prefix) {
    return new UnaryExpressionMatcher(operator, argument, prefix);
}
exports.unaryExpression = unaryExpression;
class UnionTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor(types) {
        super();
        this.types = types;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isUnionTypeAnnotation(node)) {
            return false;
        }
        if (typeof this.types === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.types)) {
            if (!(0, tupleOf_1.tupleOf)(...this.types).matchValue(node.types, [
                ...keys,
                'types',
            ])) {
                return false;
            }
        }
        else if (!this.types.matchValue(node.types, [...keys, 'types'])) {
            return false;
        }
        return true;
    }
}
exports.UnionTypeAnnotationMatcher = UnionTypeAnnotationMatcher;
function unionTypeAnnotation(types) {
    return new UnionTypeAnnotationMatcher(types);
}
exports.unionTypeAnnotation = unionTypeAnnotation;
class UpdateExpressionMatcher extends Matcher_1.Matcher {
    constructor(operator, argument, prefix) {
        super();
        this.operator = operator;
        this.argument = argument;
        this.prefix = prefix;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isUpdateExpression(node)) {
            return false;
        }
        if (typeof this.operator === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.operator === 'string') {
            if (this.operator !== node.operator) {
                return false;
            }
        }
        else if (!this.operator.matchValue(node.operator, [...keys, 'operator'])) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        if (typeof this.prefix === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.prefix === 'boolean') {
            if (this.prefix !== node.prefix) {
                return false;
            }
        }
        else if (!this.prefix.matchValue(node.prefix, [...keys, 'prefix'])) {
            return false;
        }
        return true;
    }
}
exports.UpdateExpressionMatcher = UpdateExpressionMatcher;
function updateExpression(operator, argument, prefix) {
    return new UpdateExpressionMatcher(operator, argument, prefix);
}
exports.updateExpression = updateExpression;
class V8IntrinsicIdentifierMatcher extends Matcher_1.Matcher {
    constructor(name) {
        super();
        this.name = name;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isV8IntrinsicIdentifier(node)) {
            return false;
        }
        if (typeof this.name === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.name === 'string') {
            if (this.name !== node.name) {
                return false;
            }
        }
        else if (!this.name.matchValue(node.name, [...keys, 'name'])) {
            return false;
        }
        return true;
    }
}
exports.V8IntrinsicIdentifierMatcher = V8IntrinsicIdentifierMatcher;
function v8IntrinsicIdentifier(name) {
    return new V8IntrinsicIdentifierMatcher(name);
}
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
class VariableDeclarationMatcher extends Matcher_1.Matcher {
    constructor(kind, declarations) {
        super();
        this.kind = kind;
        this.declarations = declarations;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isVariableDeclaration(node)) {
            return false;
        }
        if (typeof this.kind === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.kind === 'string') {
            if (this.kind !== node.kind) {
                return false;
            }
        }
        else if (!this.kind.matchValue(node.kind, [...keys, 'kind'])) {
            return false;
        }
        if (typeof this.declarations === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (Array.isArray(this.declarations)) {
            if (!(0, tupleOf_1.tupleOf)(...this.declarations).matchValue(node.declarations, [
                ...keys,
                'declarations',
            ])) {
                return false;
            }
        }
        else if (!this.declarations.matchValue(node.declarations, [
            ...keys,
            'declarations',
        ])) {
            return false;
        }
        return true;
    }
}
exports.VariableDeclarationMatcher = VariableDeclarationMatcher;
function variableDeclaration(kind, declarations) {
    return new VariableDeclarationMatcher(kind, declarations);
}
exports.variableDeclaration = variableDeclaration;
class VariableDeclaratorMatcher extends Matcher_1.Matcher {
    constructor(id, init) {
        super();
        this.id = id;
        this.init = init;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isVariableDeclarator(node)) {
            return false;
        }
        if (typeof this.id === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.id.matchValue(node.id, [...keys, 'id'])) {
            return false;
        }
        if (typeof this.init === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.init === null) {
            // null matcher means we expect null value
            if (node.init !== null) {
                return false;
            }
        }
        else if (!this.init.matchValue(node.init, [...keys, 'init'])) {
            return false;
        }
        return true;
    }
}
exports.VariableDeclaratorMatcher = VariableDeclaratorMatcher;
function variableDeclarator(id, init) {
    return new VariableDeclaratorMatcher(id, init);
}
exports.variableDeclarator = variableDeclarator;
class VarianceMatcher extends Matcher_1.Matcher {
    constructor(kind) {
        super();
        this.kind = kind;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isVariance(node)) {
            return false;
        }
        if (typeof this.kind === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.kind === 'string') {
            if (this.kind !== node.kind) {
                return false;
            }
        }
        else if (!this.kind.matchValue(node.kind, [...keys, 'kind'])) {
            return false;
        }
        return true;
    }
}
exports.VarianceMatcher = VarianceMatcher;
function variance(kind) {
    return new VarianceMatcher(kind);
}
exports.variance = variance;
class VoidTypeAnnotationMatcher extends Matcher_1.Matcher {
    constructor() {
        super();
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isVoidTypeAnnotation(node)) {
            return false;
        }
        return true;
    }
}
exports.VoidTypeAnnotationMatcher = VoidTypeAnnotationMatcher;
function voidTypeAnnotation() {
    return new VoidTypeAnnotationMatcher();
}
exports.voidTypeAnnotation = voidTypeAnnotation;
class WhileStatementMatcher extends Matcher_1.Matcher {
    constructor(test, body) {
        super();
        this.test = test;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isWhileStatement(node)) {
            return false;
        }
        if (typeof this.test === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.test.matchValue(node.test, [...keys, 'test'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.WhileStatementMatcher = WhileStatementMatcher;
function whileStatement(test, body) {
    return new WhileStatementMatcher(test, body);
}
exports.whileStatement = whileStatement;
class WithStatementMatcher extends Matcher_1.Matcher {
    constructor(object, body) {
        super();
        this.object = object;
        this.body = body;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isWithStatement(node)) {
            return false;
        }
        if (typeof this.object === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.object.matchValue(node.object, [...keys, 'object'])) {
            return false;
        }
        if (typeof this.body === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (!this.body.matchValue(node.body, [...keys, 'body'])) {
            return false;
        }
        return true;
    }
}
exports.WithStatementMatcher = WithStatementMatcher;
function withStatement(object, body) {
    return new WithStatementMatcher(object, body);
}
exports.withStatement = withStatement;
class YieldExpressionMatcher extends Matcher_1.Matcher {
    constructor(argument, delegate) {
        super();
        this.argument = argument;
        this.delegate = delegate;
    }
    matchValue(node, keys) {
        if (!t.isNode(node) || !t.isYieldExpression(node)) {
            return false;
        }
        if (typeof this.argument === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (this.argument === null) {
            // null matcher means we expect null value
            if (node.argument !== null) {
                return false;
            }
        }
        else if (!this.argument.matchValue(node.argument, [...keys, 'argument'])) {
            return false;
        }
        if (typeof this.delegate === 'undefined') {
            // undefined matcher means anything matches
        }
        else if (typeof this.delegate === 'boolean') {
            if (this.delegate !== node.delegate) {
                return false;
            }
        }
        else if (!this.delegate.matchValue(node.delegate, [...keys, 'delegate'])) {
            return false;
        }
        return true;
    }
}
exports.YieldExpressionMatcher = YieldExpressionMatcher;
function yieldExpression(argument, delegate) {
    return new YieldExpressionMatcher(argument, delegate);
}
exports.yieldExpression = yieldExpression;
//# sourceMappingURL=generated.js.map